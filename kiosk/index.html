<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scary Shawarma Kiosk: The Anomaly</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body { 
            margin: 0; 
            overflow: hidden; 
            background: #000; 
            font-family: 'VT323', monospace;
            user-select: none;
        }
        
        #gameCanvas { display: block; width: 100vw; height: 100vh; }
        
        /* CRT Monitor Effect */
        .crt {
            position: relative;
            height: 100vh;
            width: 100vw;
        }
        
        .crt::before {
            content: " ";
            display: block;
            position: absolute;
            top: 0; left: 0; bottom: 0; right: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), 
                        linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 2px, 3px 100%;
            pointer-events: none;
            z-index: 1000;
        }
        
        .scanline {
            width: 100%;
            height: 100px;
            z-index: 1001;
            background: linear-gradient(0deg, rgba(0,0,0,0) 0%, rgba(255, 255, 255, 0.05) 50%, rgba(0,0,0,0) 100%);
            opacity: 0.1;
            position: absolute;
            bottom: 100%;
            animation: scanline 8s linear infinite;
            pointer-events: none;
        }
        
        @keyframes scanline {
            0% { bottom: 100%; }
            100% { bottom: -100%; }
        }
        
        /* UI Elements */
        .hud-text { font-family: 'VT323', monospace; text-shadow: 2px 2px 0 #000; }
        
        #crosshair {
            position: absolute;
            top: 50%; left: 50%;
            width: 24px; height: 24px;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 100;
            mix-blend-mode: difference;
        }
        
        #crosshair::before, #crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.9);
        }
        #crosshair::before { width: 2px; height: 24px; left: 11px; top: 0; }
        #crosshair::after { width: 24px; height: 2px; left: 0; top: 11px; }
        
        .interaction-prompt {
            position: absolute;
            top: 65%; left: 50%;
            transform: translate(-50%, -50%);
            color: #ffff00;
            font-size: 28px;
            font-weight: bold;
            text-shadow: 3px 3px 0 #000, -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000;
            pointer-events: none;
            z-index: 100;
            animation: pulse 1.5s infinite;
            font-family: 'VT323', monospace;
            letter-spacing: 2px;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            50% { opacity: 0.7; transform: translate(-50%, -50%) scale(1.05); }
        }
        
        /* VHS Tracking Effect */
        .vhs-tracking {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.15),
                rgba(0, 0, 0, 0.15) 1px,
                transparent 1px,
                transparent 2px
            );
            pointer-events: none;
            z-index: 999;
            opacity: 0.3;
        }
        
        /* Camera Interface */
        #cameraInterface {
            display: none;
            position: fixed;
            inset: 0;
            background: #001100;
            z-index: 500;
            font-family: 'VT323', monospace;
        }
        
        .cam-screen {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 80vw; height: 45vw;
            background: #000;
            border: 4px solid #333;
            box-shadow: 0 0 50px rgba(0, 255, 0, 0.2);
            overflow: hidden;
        }
        
        .cam-header {
            position: absolute;
            top: 20px; left: 20px;
            color: #00ff00;
            font-size: 24px;
            text-shadow: 0 0 10px #00ff00;
            z-index: 10;
        }
        
        .cam-rec {
            position: absolute;
            top: 20px; right: 20px;
            color: #ff0000;
            font-size: 20px;
            animation: blink 1s infinite;
            z-index: 10;
        }
        
        @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0; } }
        
        .cam-controls {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            z-index: 10;
        }
        
        .cam-btn {
            background: rgba(0, 50, 0, 0.8);
            border: 2px solid #00ff00;
            color: #00ff00;
            padding: 10px 30px;
            font-family: 'VT323', monospace;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .cam-btn:hover { background: #00ff00; color: #000; }
        .cam-btn.active { background: #00ff00; color: #000; box-shadow: 0 0 20px #00ff00; }
        
        /* Night Vision Mode */
        .night-vision {
            filter: hue-rotate(90deg) saturate(3) brightness(1.2) contrast(1.3);
            box-shadow: inset 0 0 100px rgba(0, 255, 0, 0.3);
        }
        
        /* Static Noise */
        #staticCanvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            opacity: 0.15;
            pointer-events: none;
        }
        
        /* Game Over Screens */
        .jumpscare {
            position: fixed;
            top: 0; left: 0; width: 100vw; height: 100vh;
            background: #000;
            display: none;
            z-index: 10000;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }
        
        .jumpscare.active {
            display: flex;
            animation: violent-shake 0.2s infinite;
        }
        
        @keyframes violent-shake {
            0% { transform: translate(0, 0) rotate(0deg) scale(1); }
            25% { transform: translate(-20px, 20px) rotate(-5deg) scale(1.1); }
            50% { transform: translate(20px, -20px) rotate(5deg) scale(1.2); }
            75% { transform: translate(-20px, -20px) rotate(-3deg) scale(1.1); }
            100% { transform: translate(20px, 20px) rotate(3deg) scale(1); }
        }
        
        .jumpscare-face {
            width: 400px; height: 400px;
            background: radial-gradient(circle, #fff 20%, #ff0000 60%, #000 100%);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 200px;
            animation: face-morph 0.5s infinite;
        }
        
        @keyframes face-morph {
            0%, 100% { transform: scale(1) rotate(0deg); }
            50% { transform: scale(1.3) rotate(180deg); }
        }
        
        /* Inspector Penalty */
        .penalty-marker {
            position: absolute;
            width: 60px; height: 60px;
            background: radial-gradient(circle, #ff0000 30%, transparent 70%);
            border: 3px solid #ff0000;
            border-radius: 50%;
            animation: penalty-pulse 2s infinite;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-weight: bold;
            font-size: 24px;
            text-shadow: 2px 2px 4px #000;
        }
        
        @keyframes penalty-pulse {
            0%, 100% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.2); opacity: 1; box-shadow: 0 0 30px #ff0000; }
        }
        
        /* Meat Tornado Animation */
        @keyframes tornado-spin {
            0% { transform: rotateY(0deg) rotateX(5deg); }
            100% { transform: rotateY(360deg) rotateX(5deg); }
        }
        
        .meat-tornado {
            animation: tornado-spin 3s linear infinite;
            transform-style: preserve-3d;
        }
        
        /* Loading Screen */
        #loadingScreen {
            position: fixed;
            inset: 0;
            background: #000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100000;
            color: #00ff00;
            font-family: 'VT323', monospace;
        }
        
        .loading-bar {
            width: 400px;
            height: 30px;
            border: 2px solid #00ff00;
            margin-top: 20px;
            position: relative;
            overflow: hidden;
        }
        
        .loading-fill {
            height: 100%;
            background: #00ff00;
            width: 0%;
            transition: width 0.3s;
            box-shadow: 0 0 20px #00ff00;
        }
        
        /* Start Screen */
        #startScreen {
            position: fixed;
            inset: 0;
            background: linear-gradient(180deg, #0a0a0a 0%, #1a1a2e 50%, #0f0f1e 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100001;
            font-family: 'VT323', monospace;
        }
        
        .title-glitch {
            font-size: 80px;
            color: #ff6b6b;
            text-shadow: 
                0 0 10px #ff6b6b,
                0 0 20px #ff6b6b,
                0 0 40px #ff0000;
            animation: glitch-text 3s infinite;
            letter-spacing: 8px;
            margin-bottom: 10px;
        }
        
        @keyframes glitch-text {
            0%, 100% { transform: translate(0); }
            20% { transform: translate(-2px, 2px); }
            40% { transform: translate(-2px, -2px); }
            60% { transform: translate(2px, 2px); }
            80% { transform: translate(2px, -2px); }
        }
        
        .subtitle {
            font-size: 32px;
            color: #888;
            margin-bottom: 40px;
            letter-spacing: 4px;
        }
        
        .rules-board {
            background: rgba(0, 0, 0, 0.8);
            border: 3px solid #666;
            padding: 30px;
            max-width: 700px;
            margin-bottom: 40px;
            color: #ddd;
            font-size: 20px;
            line-height: 1.6;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.8);
        }
        
        .rules-board h2 {
            color: #ff6b6b;
            margin-bottom: 15px;
            font-size: 28px;
            border-bottom: 2px solid #ff6b6b;
            padding-bottom: 10px;
        }
        
        .rules-board ul {
            list-style: none;
            padding: 0;
        }
        
        .rules-board li {
            margin-bottom: 10px;
            padding-left: 20px;
            position: relative;
        }
        
        .rules-board li:before {
            content: "‚ñ∫";
            position: absolute;
            left: 0;
            color: #ff6b6b;
        }
        
        .start-btn {
            background: transparent;
            color: #ff6b6b;
            border: 3px solid #ff6b6b;
            padding: 20px 60px;
            font-size: 32px;
            font-family: 'VT323', monospace;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 4px;
            box-shadow: 0 0 20px rgba(255, 107, 107, 0.3);
        }
        
        .start-btn:hover {
            background: #ff6b6b;
            color: #000;
            box-shadow: 0 0 40px #ff6b6b;
            transform: scale(1.05);
        }
        
        /* Order Ticket */
        #orderTicket {
            position: absolute;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            width: 280px;
            background: #fff;
            color: #000;
            padding: 20px;
            font-family: 'VT323', monospace;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
            border: 2px solid #333;
            display: none;
            z-index: 50;
        }
        
        .ticket-header {
            text-align: center;
            border-bottom: 2px dashed #000;
            padding-bottom: 10px;
            margin-bottom: 15px;
            font-size: 24px;
            font-weight: bold;
        }
        
        .ticket-item {
            font-size: 20px;
            margin: 10px 0;
            display: flex;
            align-items: center;
        }
        
        .ticket-checkbox {
            width: 20px; height: 20px;
            border: 2px solid #000;
            margin-right: 10px;
            display: inline-block;
        }
        
        .ticket-checkbox.checked {
            background: #000;
            position: relative;
        }
        
        .ticket-checkbox.checked:after {
            content: "‚úì";
            color: #fff;
            position: absolute;
            top: -4px; left: 2px;
            font-size: 18px;
        }
        
        /* Strike Indicators */
        #strikeContainer {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            z-index: 100;
        }
        
        .strike {
            width: 50px; height: 50px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #666;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: #666;
            transition: all 0.3s;
        }
        
        .strike.active {
            background: #ff0000;
            border-color: #ff0000;
            color: #fff;
            box-shadow: 0 0 20px #ff0000;
            animation: strike-pulse 1s infinite;
        }
        
        @keyframes strike-pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        /* Inspector Warning */
        #inspectorWarning {
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(139, 0, 0, 0.9);
            color: #fff;
            padding: 20px 40px;
            font-size: 36px;
            border: 3px solid #ff0000;
            display: none;
            z-index: 200;
            animation: warning-flash 0.5s infinite;
            text-align: center;
        }
        
        @keyframes warning-flash {
            0%, 100% { opacity: 1; box-shadow: 0 0 30px #ff0000; }
            50% { opacity: 0.8; box-shadow: 0 0 60px #ff0000; }
        }
        
        /* Hide Under Table */
        #hidePrompt {
            position: absolute;
            top: 30%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            color: #ff0000;
            padding: 30px;
            font-size: 48px;
            border: 4px solid #ff0000;
            display: none;
            z-index: 300;
            text-align: center;
            animation: hide-pulse 0.5s infinite;
        }
        
        @keyframes hide-pulse {
            0%, 100% { transform: translateX(-50%) scale(1); }
            50% { transform: translateX(-50%) scale(1.05); }
        }
        
        /* Recipe Book */
        #recipeBook {
            position: absolute;
            right: 20px;
            top: 100px;
            width: 300px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #8B4513;
            color: #DEB887;
            padding: 20px;
            display: none;
            z-index: 50;
            font-family: 'VT323', monospace;
        }
        
        .recipe-title {
            color: #ff6b6b;
            font-size: 28px;
            border-bottom: 2px solid #8B4513;
            margin-bottom: 15px;
            text-align: center;
        }
        
        .recipe-step {
            margin: 10px 0;
            font-size: 20px;
            padding-left: 10px;
            border-left: 3px solid #8B4513;
        }
        
        /* Notification System */
        #notification {
            position: absolute;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            color: #fff;
            padding: 15px 30px;
            font-size: 24px;
            border: 2px solid #fff;
            display: none;
            z-index: 150;
            animation: slide-down 0.3s;
        }
        
        @keyframes slide-down {
            from { transform: translateX(-50%) translateY(-50px); opacity: 0; }
            to { transform: translateX(-50%) translateY(0); opacity: 1; }
        }
        
        /* Red Alert Mode */
        .red-alert {
            animation: red-flash 1s infinite;
        }
        
        @keyframes red-flash {
            0%, 100% { box-shadow: inset 0 0 0 rgba(255, 0, 0, 0); }
            50% { box-shadow: inset 0 0 100px rgba(255, 0, 0, 0.5); }
        }
    </style>
</head>
<body class="crt">
    <div class="scanline"></div>
    <div class="vhs-tracking"></div>
    
    <!-- Loading Screen -->
    <div id="loadingScreen">
        <div style="font-size: 48px; margin-bottom: 20px;">INITIALIZING KIOSK SYSTEMS...</div>
        <div class="loading-bar">
            <div class="loading-fill" id="loadingFill"></div>
        </div>
        <div id="loadingText" style="margin-top: 20px; font-size: 24px;">Loading assets...</div>
    </div>
    
    <!-- Start Screen -->
    <div id="startScreen">
        <div class="title-glitch">SHAWARMA KIOSK</div>
        <div class="subtitle">THE ANOMALY</div>
        
        <div class="rules-board">
            <h2>EMPLOYEE HANDBOOK - NIGHT SHIFT PROTOCOLS</h2>
            <ul>
                <li>Check CCTV cameras (TAB) before serving ANY customer</li>
                <li>Use Night Vision (R) to detect hidden anomalies</li>
                <li>Close shutters (E on button) on suspicious customers</li>
                <li>Prepare orders: Lavash ‚Üí Chicken ‚Üí Toppings ‚Üí Roll</li>
                <li>If meat whispers or pulses, TURN OFF GRILL and EXIT immediately</li>
                <li>At 2:00 AM, if lights turn red, EXIT through back door</li>
                <li>Five penalties = TERMINATION (The Inspector claims you)</li>
                <li>Some "anomalies" are just odd customers - use judgment</li>
                <li>Never look directly at the Faceless Man's... face</li>
                <li>If you see The Watcher, stare at it until it leaves</li>
            </ul>
        </div>
        
        <button class="start-btn" onclick="startGame()">BEGIN NIGHT SHIFT</button>
        <div style="margin-top: 20px; color: #666; font-size: 18px;">
            [WASD] Move ‚Ä¢ [Mouse] Look ‚Ä¢ [E] Interact ‚Ä¢ [Tab] Cameras ‚Ä¢ [R] Night Vision ‚Ä¢ [Shift] Sprint
        </div>
    </div>
    
    <!-- Game UI -->
    <div id="gameUI" style="display: none;">
        <div id="crosshair"></div>
        <div id="interactionPrompt" class="interaction-prompt" style="display: none;"></div>
        
        <!-- Top HUD -->
        <div style="position: absolute; top: 20px; left: 20px; z-index: 100;">
            <div style="background: rgba(0,0,0,0.8); border: 2px solid #ff6b6b; padding: 15px; border-radius: 5px;">
                <div style="color: #ff6b6b; font-size: 18px; margin-bottom: 5px;">TIME</div>
                <div id="timeDisplay" style="color: #fff; font-size: 36px; font-weight: bold;" class="hud-text">12:00 AM</div>
                <div style="color: #888; font-size: 16px; margin-top: 5px;">NIGHT 1</div>
            </div>
        </div>
        
        <!-- Power Meter -->
        <div style="position: absolute; top: 20px; right: 20px; z-index: 100;">
            <div style="background: rgba(0,0,0,0.8); border: 2px solid #ffff00; padding: 15px; border-radius: 5px; text-align: right;">
                <div style="color: #ffff00; font-size: 18px; margin-bottom: 5px;">POWER</div>
                <div style="width: 200px; height: 25px; background: #333; border: 2px solid #555; position: relative; overflow: hidden;">
                    <div id="powerBar" style="height: 100%; background: linear-gradient(90deg, #ff0000, #ffff00, #00ff00); width: 100%; transition: width 0.5s;"></div>
                </div>
                <div id="powerText" style="color: #00ff00; font-size: 20px; margin-top: 5px;">100%</div>
            </div>
        </div>
        
        <!-- Order Ticket -->
        <div id="orderTicket">
            <div class="ticket-header">ORDER #<span id="orderNum">001</span></div>
            <div id="orderDetails"></div>
        </div>
        
        <!-- Recipe Book (Toggleable) -->
        <div id="recipeBook">
            <div class="recipe-title">RECIPE GUIDE</div>
            <div class="recipe-step">1. Place Lavash on counter</div>
            <div class="recipe-step">2. Add Chicken from spit</div>
            <div class="recipe-step">3. Add requested toppings</div>
            <div class="recipe-step">4. Roll and serve</div>
            <div style="margin-top: 15px; padding-top: 15px; border-top: 2px solid #8B4513; color: #ff6b6b; font-size: 18px;">
                WARNING: Check cameras before serving!
            </div>
        </div>
        
        <!-- Strike Container -->
        <div id="strikeContainer">
            <div class="strike" id="strike1">1</div>
            <div class="strike" id="strike2">2</div>
            <div class="strike" id="strike3">3</div>
            <div class="strike" id="strike4">4</div>
            <div class="strike" id="strike5">5</div>
        </div>
        
        <!-- Inspector Warning -->
        <div id="inspectorWarning">
            <div>‚ö† THE INSPECTOR APPROACHES ‚ö†</div>
            <div style="font-size: 20px; margin-top: 10px;">Mistakes have been made...</div>
        </div>
        
        <!-- Hide Prompt -->
        <div id="hidePrompt">
            HIDE UNDER TABLE NOW!<br>
            <span style="font-size: 24px;">(Press C to crouch under center table)</span>
        </div>
        
        <!-- Notification -->
        <div id="notification"></div>
    </div>
    
    <!-- Camera Interface -->
    <div id="cameraInterface">
        <div class="cam-screen" id="camScreen">
            <canvas id="cameraCanvas" style="width: 100%; height: 100%;"></canvas>
            <div class="cam-header" id="camHeader">CAM_01 - FRONT WINDOW</div>
            <div class="cam-rec">‚óè REC</div>
            <div id="camStatus" style="position: absolute; bottom: 80px; left: 20px; color: #00ff00; font-size: 18px;"></div>
        </div>
        <div class="cam-controls">
            <button class="cam-btn active" onclick="switchCamera(1)">CAM 1 - FRONT</button>
            <button class="cam-btn" onclick="switchCamera(2)">CAM 2 - BACK</button>
            <button class="cam-btn" onclick="toggleNightVision()" id="nvBtn">NIGHT VISION: OFF</button>
            <button class="cam-btn" onclick="closeCameras()" style="background: #ff0000; border-color: #ff0000; color: #fff;">EXIT [TAB]</button>
        </div>
        <div style="position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); color: #00ff00; font-size: 18px;">
            Use Night Vision to detect hidden anomalies
        </div>
    </div>
    
    <!-- Jumpscare Overlay -->
    <div id="jumpscare" class="jumpscare">
        <div style="font-size: 60px; color: #ff0000; margin-bottom: 20px; text-shadow: 0 0 50px #ff0000;">BEHIND YOU</div>
        <div class="jumpscare-face">üëÅÔ∏è</div>
        <div style="font-size: 40px; color: #fff; margin-top: 20px; animation: glitch-text 0.1s infinite;">DON'T LOOK BACK</div>
    </div>
    
    <!-- Game Over -->
    <div id="gameOver" style="display: none; position: fixed; inset: 0; background: #000; z-index: 100000; flex-direction: column; align-items: center; justify-content: center;">
        <div id="gameOverTitle" style="font-size: 80px; color: #ff0000; margin-bottom: 20px; text-shadow: 0 0 50px #ff0000;">SHIFT ENDED</div>
        <div id="gameOverReason" style="font-size: 32px; color: #fff; margin-bottom: 40px; max-width: 800px; text-align: center;"></div>
        <button onclick="location.reload()" style="background: transparent; color: #ff6b6b; border: 3px solid #ff6b6b; padding: 20px 60px; font-size: 32px; font-family: 'VT323', monospace; cursor: pointer; text-transform: uppercase; letter-spacing: 4px;">
            TRY AGAIN
        </button>
    </div>
    
    <canvas id="gameCanvas"></canvas>

    <script>
        // ==========================================
        // EXACT REPLICA OF SCARY SHAWARMA KIOSK
        // ==========================================
        
        let scene, camera, renderer;
        let player = { x: 0, y: 1.6, z: 2, vx: 0, vz: 0, rotation: 0, pitch: 0 };
        let keys = {};
        let isLocked = false;
        let gameTime = 0; // 0 to 360 (6 hours)
        let power = 100;
        let strikes = 0;
        let isGameOver = false;
        let inCameras = false;
        let nightVision = false;
        let currentCamera = 1;
        let currentOrder = null;
        let customers = [];
        let gameStarted = false;
        let shutterClosed = false;
        let equipmentOn = { meat: true, lights: true };
        let holdingItem = null;
        let preparedShawarma = null;
        let isHiding = false;
        let anomalyEvents = [];
        let inspectorActive = false;
        let currentNight = 1;
        
        // Anomaly Types (Exact from game)
        const ANOMALIES = {
            // True Anomalies (Close shutter)
            SKINWALKER: { name: 'Skinwalker', detect: 'camera', nvOnly: false, desc: 'Pale cracked skin, no hair' },
            BLACK_HOLES: { name: 'Black Holes', detect: 'camera_back', nvOnly: false, desc: 'Holes in back' },
            INJURED: { name: 'Injured Anomaly', detect: 'visual', nvOnly: false, desc: 'Grazes on arms, protruding collarbones' },
            NIGHTVISION_MISSING: { name: 'Nightvision Missing', detect: 'camera', nvOnly: true, desc: 'Disappears in night vision' },
            BODY_DOUBLE: { name: 'Body Double', detect: 'camera', nvOnly: false, desc: 'Double visible on camera' },
            BACK_DOUBLE: { name: 'Out Back Double', detect: 'camera_back', nvOnly: false, desc: 'Double in back camera' },
            SCREAMER: { name: 'The Screamer', detect: 'camera', nvOnly: false, desc: 'Jumpscare on camera', jumpscare: true },
            CCTV_PASSENGER: { name: 'CCTV Passenger', detect: 'camera', nvOnly: false, desc: 'Creature riding back' },
            NIGHTVISION_DANCER: { name: 'Nightvision Dancer', detect: 'camera', nvOnly: true, desc: 'Dances in night vision' },
            GIBBERISH: { name: 'Gibberish Speaker', detect: 'audio', nvOnly: false, desc: 'Speaks random letters' },
            DOPPELGANGER: { name: 'The Doppelganger', detect: 'audio', nvOnly: false, desc: 'Mentions warm shawarma' },
            HACKER: { name: 'The Hacker', detect: 'audio', nvOnly: false, desc: 'Mentions your username' },
            SANTA: { name: 'Santa', detect: 'visual', nvOnly: false, desc: 'Disturbing face, says Merry Evening' },
            WHITE_EYES: { name: 'White Eyes Lady', detect: 'visual', nvOnly: false, desc: 'Glassy white eyes' },
            OPPOSITE_VOICE: { name: 'Opposite Gender Voice', detect: 'audio', nvOnly: false, desc: 'Wrong voice gender' },
            TWINS: { name: 'Broken Neck Twins', detect: 'visual', nvOnly: false, desc: 'Necks at impossible angles' },
            HEADLESS: { name: 'Headless', detect: 'visual', nvOnly: false, desc: 'Literally no head' },
            FACE_THIEF: { name: 'Face Thief', detect: 'visual', nvOnly: false, desc: 'Removes face, itchy' },
            CHOPPED_HEAD: { name: 'Chopped Head', detect: 'visual', nvOnly: false, desc: 'Head split under nose' },
            CLOWN: { name: 'Clown', detect: 'visual', nvOnly: false, desc: 'Walks slowly from across road' },
            DEER: { name: 'Wild Deer', detect: 'visual', nvOnly: false, desc: 'Big white deer on road' },
            POLYCORIA: { name: 'Polycoria Woman', detect: 'visual', nvOnly: false, desc: 'Eyes rolling in sockets' },
            
            // Safe Oddities (Serve them)
            CAT_LADY: { name: 'Cat Lady', safe: true, desc: 'Cat with face marking on back' },
            PROTEIN_LADY: { name: 'Protein Lady', safe: true, desc: 'Stretching, gym training' },
            KARATE_MASTER: { name: 'Karate Master', safe: true, desc: 'Practicing martial arts' },
            DANCER: { name: 'The Dancer', safe: true, desc: 'Dancing in person (not on cam)' },
            DRUNKARD: { name: 'Drunk Guy', safe: true, desc: 'No money, will pay later' },
            PHONE_LADY: { name: 'Phone Lady', safe: true, desc: 'Screaming ringtone' },
            ONE_HAND: { name: 'One-Handed Lady', safe: true, desc: 'Asks not to cut shawarma' },
            SHORT_KING: { name: 'Narcissistic Shorty', safe: true, desc: 'Confident short person' },
            WEIRD_GUY: { name: 'Weird Guy', safe: true, desc: 'Red shirt, says day feels floaty' },
            TALL_MAN: { name: 'Tall Man', safe: true, desc: 'Very tall' },
            FAT_SPORTS: { name: 'Fat Woman Sports', safe: true, desc: 'Stretching, protein day' },
            FAT_UNPLEASANT: { name: 'Fat Unpleasant Man', safe: true, desc: 'Offended easily, orders two' },
            MICHAEL_MYERS: { name: 'Michael Myers', safe: true, desc: 'Halloween costume' },
            
            // Special Interactions
            SMILING_MAN: { name: 'Smiling Man', special: true, desc: 'Wide grin, give soda, take envelope' },
            FACELESS: { name: 'Faceless Man', special: true, desc: 'Hole where face should be, dont look at hole' },
            BOOGER: { name: 'Booger Man', special: true, desc: 'Offers $1000 to eat booger, decline' },
            NARRATOR: { name: 'The Narrator', special: true, desc: 'Voice narrates your actions' },
            DEATH_NOTE: { name: 'Death Note', special: true, desc: 'Light Yagami asks you to write name' }
        };
        
        // Three.js Setup
        function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050505);
            scene.fog = new THREE.Fog(0x050505, 0.5, 25);
            
            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(player.x, player.y, player.z);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('gameCanvas'), antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            
            buildExactKiosk();
            setupExactLighting();
            setupInputs();
            
            // Start loop
            animate();
        }
        
        function buildExactKiosk() {
            // Materials
            const wallMat = new THREE.MeshStandardMaterial({ color: 0x666666, roughness: 0.9 });
            const floorMat = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.8 });
            const metalMat = new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.7, roughness: 0.3 });
            const woodMat = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.8 });
            
            // Floor (Exact 10x10 kiosk)
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(10, 10), floorMat);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);
            
            // Back Wall
            const backWall = new THREE.Mesh(new THREE.BoxGeometry(10, 4, 0.2), wallMat);
            backWall.position.set(0, 2, -5);
            backWall.castShadow = true;
            scene.add(backWall);
            
            // Left Wall
            const leftWall = new THREE.Mesh(new THREE.BoxGeometry(0.2, 4, 10), wallMat);
            leftWall.position.set(-5, 2, 0);
            leftWall.castShadow = true;
            scene.add(leftWall);
            
            // Right Wall
            const rightWall = new THREE.Mesh(new THREE.BoxGeometry(0.2, 4, 10), wallMat);
            rightWall.position.set(5, 2, 0);
            rightWall.castShadow = true;
            scene.add(rightWall);
            
            // Front Wall with Service Window (Exact layout)
            const frontLeft = new THREE.Mesh(new THREE.BoxGeometry(2.5, 4, 0.2), wallMat);
            frontLeft.position.set(-3.75, 2, 5);
            scene.add(frontLeft);
            
            const frontRight = new THREE.Mesh(new THREE.BoxGeometry(2.5, 4, 0.2), wallMat);
            frontRight.position.set(3.75, 2, 5);
            scene.add(frontRight);
            
            const frontTop = new THREE.Mesh(new THREE.BoxGeometry(5, 1.5, 0.2), wallMat);
            frontTop.position.set(0, 3.25, 5);
            scene.add(frontTop);
            
            // Service Counter (Exact position)
            const counter = new THREE.Mesh(new THREE.BoxGeometry(4, 1.2, 1), woodMat);
            counter.position.set(0, 0.6, 4.5);
            counter.castShadow = true;
            counter.userData = { type: 'counter', name: 'Service Counter' };
            scene.add(counter);
            
            // Prep Station (Exact position - left of counter)
            const prepStation = new THREE.Mesh(new THREE.BoxGeometry(2, 1, 1.5), metalMat);
            prepStation.position.set(-3, 0.5, 3);
            prepStation.userData = { type: 'prep', name: 'Prep Station' };
            scene.add(prepStation);
            
            // Shawarma Machine (Meat Tornado) - Exact position right side
            const machineBase = new THREE.Mesh(new THREE.BoxGeometry(1.5, 2, 1.5), metalMat);
            machineBase.position.set(3, 1, 2);
            machineBase.userData = { type: 'machine', name: 'Shawarma Machine' };
            scene.add(machineBase);
            
            // The Meat (Vertical Rotisserie/Tornado)
            const meatGroup = new THREE.Group();
            meatGroup.position.set(3, 2.5, 2);
            
            // Vertical spit
            const spit = new THREE.Mesh(
                new THREE.CylinderGeometry(0.05, 0.05, 2, 8),
                new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.8 })
            );
            meatGroup.add(spit);
            
            // Meat layers (The Tornado)
            for (let i = 0; i < 8; i++) {
                const meatLayer = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.4 - (i * 0.02), 0.4 - (i * 0.02), 0.2, 16),
                    new THREE.MeshStandardMaterial({ 
                        color: 0x8B0000,
                        emissive: 0x330000,
                        emissiveIntensity: 0.2,
                        roughness: 0.7
                    })
                );
                meatLayer.position.y = -0.8 + (i * 0.22);
                meatLayer.rotation.y = Math.random() * Math.PI;
                meatGroup.add(meatLayer);
            }
            
            scene.add(meatGroup);
            window.meatTornado = meatGroup;
            
            // Grill/Slicer
            const grill = new THREE.Mesh(
                new THREE.BoxGeometry(0.8, 0.1, 0.8),
                new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.5 })
            );
            grill.position.set(3, 1.1, 2.5);
            grill.userData = { type: 'grill', name: 'Meat Slicer (E)' };
            scene.add(grill);
            
            // Power Switch for Meat (Right wall)
            const powerSwitch = new THREE.Mesh(
                new THREE.BoxGeometry(0.3, 0.4, 0.1),
                new THREE.MeshStandardMaterial({ color: equipmentOn.meat ? 0x00ff00 : 0xff0000, emissive: equipmentOn.meat ? 0x00ff00 : 0xff0000, emissiveIntensity: 0.3 })
            );
            powerSwitch.position.set(4.9, 1.5, 2);
            powerSwitch.rotation.y = -Math.PI / 2;
            powerSwitch.userData = { type: 'power_meat', name: 'Meat Power Switch (E)' };
            scene.add(powerSwitch);
            window.meatSwitch = powerSwitch;
            
            // Ingredients Station
            // Lavash bread stack
            const lavashStack = new THREE.Mesh(
                new THREE.BoxGeometry(0.6, 0.3, 0.6),
                new THREE.MeshStandardMaterial({ color: 0xf5deb3 })
            );
            lavashStack.position.set(-3, 1.15, 3);
            lavashStack.userData = { type: 'ingredient', item: 'lavash', name: 'Lavash Bread (E)' };
            scene.add(lavashStack);
            
            // Toppings containers
            const toppings = [
                { name: 'lettuce', color: 0x00ff00, pos: [-3.5, 1.1, 2.5] },
                { name: 'tomato', color: 0xff0000, pos: [-3, 1.1, 2.5] },
                { name: 'pickle', color: 0x228b22, pos: [-2.5, 1.1, 2.5] },
                { name: 'onion', color: 0xdda0dd, pos: [-3.5, 1.1, 3.5] }
            ];
            
            toppings.forEach(t => {
                const bowl = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.2, 0.15, 0.2, 8),
                    new THREE.MeshStandardMaterial({ color: t.color })
                );
                bowl.position.set(...t.pos);
                bowl.userData = { type: 'ingredient', item: t.name, name: t.name.charAt(0).toUpperCase() + t.name.slice(1) + ' (E)' };
                scene.add(bowl);
            });
            
            // Fridge (Left back)
            const fridge = new THREE.Mesh(
                new THREE.BoxGeometry(1.5, 3, 1.5),
                new THREE.MeshStandardMaterial({ color: 0xdddddd, metalness: 0.3, roughness: 0.2 })
            );
            fridge.position.set(-3.5, 1.5, -3);
            fridge.userData = { type: 'fridge', name: 'Fridge (E)' };
            scene.add(fridge);
            
            // Center Table (For hiding under)
            const centerTable = new THREE.Mesh(
                new THREE.BoxGeometry(2, 0.8, 1.5),
                woodMat
            );
            centerTable.position.set(0, 0.4, 0);
            centerTable.userData = { type: 'table', name: 'Center Table (C to hide)' };
            scene.add(centerTable);
            
            // Shutter Button (Red button near window)
            const shutterBtn = new THREE.Mesh(
                new THREE.BoxGeometry(0.3, 0.3, 0.1),
                new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0xff0000, emissiveIntensity: 0.3 })
            );
            shutterBtn.position.set(2, 1.5, 4.8);
            shutterBtn.userData = { type: 'shutter', name: 'Window Shutter (E)' };
            scene.add(shutterBtn);
            
            // Window Shutter (Metal roller)
            const shutter = new THREE.Mesh(
                new THREE.BoxGeometry(5, 2.5, 0.1),
                new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.6, roughness: 0.4 })
            );
            shutter.position.set(0, 5, 5); // Start raised
            shutter.visible = false;
            scene.add(shutter);
            window.windowShutter = shutter;
            
            // CCTV Monitor (Left of counter)
            const monitor = new THREE.Mesh(
                new THREE.BoxGeometry(0.8, 0.6, 0.1),
                new THREE.MeshStandardMaterial({ color: 0x111111 })
            );
            monitor.position.set(-1.5, 1.8, 4.8);
            monitor.userData = { type: 'monitor', name: 'CCTV Monitor (Tab)' };
            scene.add(monitor);
            
            // Monitor Screen Glow
            const screenGlow = new THREE.PointLight(0x00ff00, 0.5, 3);
            screenGlow.position.set(-1.5, 1.8, 4.5);
            scene.add(screenGlow);
            
            // Rules Board (Right wall)
            const rulesBoard = new THREE.Mesh(
                new THREE.PlaneGeometry(2, 1.5),
                new THREE.MeshStandardMaterial({ color: 0xffffee })
            );
            rulesBoard.position.set(4.9, 2, 0);
            rulesBoard.rotation.y = -Math.PI / 2;
            scene.add(rulesBoard);
            
            // Clock (Wall)
            const clock = new THREE.Mesh(
                new THREE.CircleGeometry(0.4, 32),
                new THREE.MeshStandardMaterial({ color: 0xffffff })
            );
            clock.position.set(0, 3, -4.9);
            scene.add(clock);
            
            // Back Door (For inspection escape)
            const backDoor = new THREE.Mesh(
                new THREE.BoxGeometry(1.5, 2.5, 0.1),
                new THREE.MeshStandardMaterial({ color: 0x4a4a4a })
            );
            backDoor.position.set(3, 1.25, -4.9);
            backDoor.userData = { type: 'door', name: 'Back Door (E)' };
            scene.add(backDoor);
            
            // Outside ground
            const outsideGround = new THREE.Mesh(
                new THREE.PlaneGeometry(100, 100),
                new THREE.MeshStandardMaterial({ color: 0x1a1a2e })
            );
            outsideGround.rotation.x = -Math.PI / 2;
            outsideGround.position.y = -0.1;
            outsideGround.position.z = 30;
            scene.add(outsideGround);
            
            // Street
            const street = new THREE.Mesh(
                new THREE.PlaneGeometry(20, 100),
                new THREE.MeshStandardMaterial({ color: 0x2a2a3a })
            );
            street.rotation.x = -Math.PI / 2;
            street.position.set(0, -0.05, 30);
            scene.add(street);
            
            // Customer spawn point
            window.customerSpawn = new THREE.Vector3(0, 0, 12);
        }
        
        function setupExactLighting() {
            // Main ceiling light (Warm)
            window.mainLight = new THREE.PointLight(0xffaa77, 1, 15);
            window.mainLight.position.set(0, 3.5, 0);
            window.mainLight.castShadow = true;
            window.mainLight.shadow.mapSize.width = 2048;
            window.mainLight.shadow.mapSize.height = 2048;
            scene.add(window.mainLight);
            
            // Window light (Cool outside)
            const windowLight = new THREE.PointLight(0x4444ff, 0.4, 10);
            windowLight.position.set(0, 2, 4);
            scene.add(windowLight);
            
            // Ambient
            const ambient = new THREE.AmbientLight(0x404040, 0.3);
            scene.add(ambient);
            
            // Meat warmer light (Red glow)
            window.meatLight = new THREE.PointLight(0xff0000, 0.3, 3);
            window.meatLight.position.set(3, 3, 2);
            scene.add(window.meatLight);
        }
        
        function setupInputs() {
            document.addEventListener('keydown', (e) => {
                keys[e.key.toLowerCase()] = true;
                
                if (e.key === 'Tab') {
                    e.preventDefault();
                    toggleCameras();
                }
                if (e.key.toLowerCase() === 'e') {
                    interact();
                }
                if (e.key.toLowerCase() === 'r' && inCameras) {
                    toggleNightVision();
                }
                if (e.key.toLowerCase() === 'c') {
                    toggleHide();
                }
            });
            
            document.addEventListener('keyup', (e) => {
                keys[e.key.toLowerCase()] = false;
            });
            
            document.addEventListener('mousemove', (e) => {
                if (!isLocked || inCameras || isHiding) return;
                
                const sensitivity = 0.002;
                player.rotation -= e.movementX * sensitivity;
                player.pitch -= e.movementY * sensitivity;
                player.pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, player.pitch));
                
                camera.rotation.order = 'YXZ';
                camera.rotation.y = player.rotation;
                camera.rotation.x = player.pitch;
            });
            
            document.addEventListener('click', () => {
                if (!gameStarted || isGameOver) return;
                if (!isLocked && !inCameras && !isHiding) {
                    document.body.requestPointerLock();
                }
            });
            
            document.addEventListener('pointerlockchange', () => {
                isLocked = document.pointerLockElement === document.body;
            });
        }
        
        function toggleCameras() {
            if (!gameStarted || isGameOver || isHiding) return;
            
            inCameras = !inCameras;
            const camInterface = document.getElementById('cameraInterface');
            
            if (inCameras) {
                camInterface.style.display = 'block';
                document.exitPointerLock();
                updateCameraView();
            } else {
                camInterface.style.display = 'none';
                document.body.requestPointerLock();
            }
        }
        
        function switchCamera(cam) {
            currentCamera = cam;
            document.querySelectorAll('.cam-btn').forEach((btn, idx) => {
                if (idx < 2) btn.classList.toggle('active', idx === cam - 1);
            });
            document.getElementById('camHeader').textContent = `CAM_0${cam} - ${cam === 1 ? 'FRONT WINDOW' : 'BACK ALLEY'}`;
            updateCameraView();
        }
        
        function toggleNightVision() {
            nightVision = !nightVision;
            const btn = document.getElementById('nvBtn');
            const screen = document.getElementById('camScreen');
            
            if (nightVision) {
                btn.textContent = 'NIGHT VISION: ON';
                btn.classList.add('active');
                screen.classList.add('night-vision');
            } else {
                btn.textContent = 'NIGHT VISION: OFF';
                btn.classList.remove('active');
                screen.classList.remove('night-vision');
            }
            updateCameraView();
        }
        
        function closeCameras() {
            inCameras = false;
            document.getElementById('cameraInterface').style.display = 'none';
            document.body.requestPointerLock();
        }
        
        function updateCameraView() {
            const canvas = document.getElementById('cameraCanvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 1280;
            canvas.height = 720;
            
            // Clear
            ctx.fillStyle = nightVision ? '#001100' : '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Static noise
            for (let i = 0; i < 10000; i++) {
                ctx.fillStyle = nightVision ? 
                    `rgba(0, ${Math.random() * 255}, 0, ${Math.random() * 0.2})` :
                    `rgba(255, 255, 255, ${Math.random() * 0.1})`;
                ctx.fillRect(Math.random() * canvas.width, Math.random() * canvas.height, 2, 2);
            }
            
            // Draw customer if present
            if (customers.length > 0 && !shutterClosed) {
                const customer = customers[0];
                drawCustomerOnCamera(ctx, customer, canvas.width, canvas.height);
            }
            
            // Scanlines
            ctx.fillStyle = nightVision ? 'rgba(0, 255, 0, 0.1)' : 'rgba(255, 255, 255, 0.05)';
            for (let y = 0; y < canvas.height; y += 4) {
                ctx.fillRect(0, y, canvas.width, 2);
            }
            
            // Status text
            const status = document.getElementById('camStatus');
            if (customers.length > 0) {
                const c = customers[0];
                if (c.isAnomaly && nightVision && c.anomalyType === 'NIGHTVISION_MISSING') {
                    status.textContent = '‚ö† TARGET NOT VISIBLE IN NV MODE';
                    status.style.color = '#ff0000';
                } else if (c.isAnomaly) {
                    status.textContent = '‚ö† ANOMALY DETECTED';
                    status.style.color = '#ff0000';
                } else {
                    status.textContent = '‚úì HUMAN CONFIRMED';
                    status.style.color = '#00ff00';
                }
            } else {
                status.textContent = 'SCANNING...';
                status.style.color = '#00ff00';
            }
            
            if (inCameras) requestAnimationFrame(updateCameraView);
        }
        
        function drawCustomerOnCamera(ctx, customer, w, h) {
            const centerX = w / 2;
            const centerY = h / 2 + 50;
            
            // Silhouette
            ctx.fillStyle = customer.isAnomaly ? '#ff0000' : '#00ff00';
            if (nightVision && customer.anomalyType === 'NIGHTVISION_MISSING') {
                ctx.fillStyle = 'rgba(0,0,0,0)'; // Invisible in NV
            }
            
            // Body
            ctx.fillRect(centerX - 60, centerY - 100, 120, 250);
            
            // Head
            ctx.beginPath();
            ctx.arc(centerX, centerY - 140, 50, 0, Math.PI * 2);
            ctx.fill();
            
            // Anomaly specific visuals
            if (customer.isAnomaly) {
                if (customer.anomalyType === 'SCREAMER' && Math.random() > 0.7) {
                    // Jumpscare effect
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(0, 0, w, h);
                    ctx.fillStyle = '#ff0000';
                    ctx.font = '100px monospace';
                    ctx.fillText('SCREAM', centerX - 150, centerY);
                }
                
                if (customer.anomalyType === 'TWINS') {
                    // Draw second head
                    ctx.beginPath();
                    ctx.arc(centerX + 80, centerY - 140, 40, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                if (customer.anomalyType === 'HEADLESS') {
                    // No head drawn
                    ctx.fillStyle = '#000000';
                    ctx.beginPath();
                    ctx.arc(centerX, centerY - 140, 50, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }
        
        function interact() {
            if (isGameOver || inCameras || isHiding) return;
            
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            
            const intersects = raycaster.intersectObjects(scene.children, true);
            if (intersects.length > 0) {
                const obj = intersects[0].object;
                if (obj.userData.type) {
                    handleInteraction(obj.userData, obj);
                }
            }
        }
        
        function handleInteraction(data, obj) {
            switch(data.type) {
                case 'shutter':
                    toggleShutter();
                    break;
                case 'power_meat':
                    toggleMeatPower();
                    break;
                case 'grill':
                    sliceMeat();
                    break;
                case 'ingredient':
                    takeIngredient(data.item);
                    break;
                case 'prep':
                    prepareFood();
                    break;
                case 'counter':
                    serveOrder();
                    break;
                case 'fridge':
                    openFridge();
                    break;
                case 'monitor':
                    toggleCameras();
                    break;
                case 'door':
                    if (inspectorActive) escapeInspection();
                    break;
            }
        }
        
        function toggleShutter() {
            shutterClosed = !shutterClosed;
            window.windowShutter.visible = shutterClosed;
            window.windowShutter.position.y = shutterClosed ? 3.75 : 5;
            
            showNotification(shutterClosed ? "SHUTTER CLOSED" : "SHUTTER OPEN");
            
            // If anomaly present and shutter closed, they leave
            if (shutterClosed && customers.length > 0) {
                const c = customers[0];
                if (c.isAnomaly) {
                    showNotification("ANOMALY REPELLED");
                    removeCustomer();
                } else {
                    showNotification("CUSTOMER LEFT (ANGRY)");
                    addStrike();
                    removeCustomer();
                }
            }
        }
        
        function toggleMeatPower() {
            equipmentOn.meat = !equipmentOn.meat;
            window.meatSwitch.material.color.setHex(equipmentOn.meat ? 0x00ff00 : 0xff0000);
            window.meatSwitch.material.emissive.setHex(equipmentOn.meat ? 0x00ff00 : 0xff0000);
            showNotification(equipmentOn.meat ? "MEAT GRILL ON" : "MEAT GRILL OFF");
            
            // If meat whispering event active, turning off saves you
            if (window.meatEventActive && !equipmentOn.meat) {
                showNotification("GOOD! NOW LEAVE THE KIOSK!");
                window.meatSafe = true;
            }
        }
        
        function sliceMeat() {
            if (!equipmentOn.meat) {
                showNotification("GRILL IS OFF");
                return;
            }
            if (holdingItem) {
                showNotification("ALREADY HOLDING SOMETHING");
                return;
            }
            holdingItem = 'meat';
            showNotification("SLICED MEAT ACQUIRED");
        }
        
        function takeIngredient(item) {
            if (holdingItem) {
                showNotification("DROP CURRENT ITEM FIRST (E on prep)");
                return;
            }
            holdingItem = item;
            showNotification(`${item.toUpperCase()} ACQUIRED`);
        }
        
        function prepareFood() {
            if (!holdingItem) {
                showNotification("NOT HOLDING ANYTHING");
                return;
            }
            
            if (!preparedShawarma) preparedShawarma = { lavash: false, meat: false, toppings: [] };
            
            if (holdingItem === 'lavash' && !preparedShawarma.lavash) {
                preparedShawarma.lavash = true;
                showNotification("LAVASH PLACED");
                holdingItem = null;
            } else if (holdingItem === 'meat' && preparedShawarma.lavash && !preparedShawarma.meat) {
                preparedShawarma.meat = true;
                showNotification("MEAT ADDED");
                holdingItem = null;
            } else if (['lettuce', 'tomato', 'pickle', 'onion'].includes(holdingItem) && preparedShawarma.meat) {
                preparedShawarma.toppings.push(holdingItem);
                showNotification(`${holdingItem.toUpperCase()} ADDED`);
                holdingItem = null;
            } else {
                showNotification("WRONG ORDER! CHECK RECIPE");
            }
            
            updateOrderTicket();
        }
        
        function serveOrder() {
            if (!currentOrder) {
                showNotification("NO CUSTOMER WAITING");
                return;
            }
            
            if (!preparedShawarma || !preparedShawarma.lavash || !preparedShawarma.meat) {
                showNotification("SHAWARMA NOT READY");
                return;
            }
            
            // Check if anomaly
            if (currentOrder.isAnomaly) {
                showNotification("‚ö† YOU SERVED AN ANOMALY!");
                addStrike();
                triggerJumpscare();
            } else {
                showNotification("ORDER COMPLETE! +$");
                // Success
            }
            
            preparedShawarma = null;
            holdingItem = null;
            removeCustomer();
            updateOrderTicket();
        }
        
        function openFridge() {
            showNotification("FRIDGE OPENED - SODA AVAILABLE");
            // Soda for Smiling Man
        }
        
        function toggleHide() {
            if (!isHiding && player.z > -1 && player.z < 1 && player.x > -1 && player.x < 1) {
                isHiding = true;
                showNotification("HIDING UNDER TABLE - EYES CLOSED");
                document.getElementById('gameCanvas').style.filter = 'brightness(0)';
            } else if (isHiding) {
                isHiding = false;
                document.getElementById('gameCanvas').style.filter = 'none';
                showNotification("NO LONGER HIDING");
            }
        }
        
        function escapeInspection() {
            showNotification("ESCAPED THROUGH BACK DOOR");
            inspectorActive = false;
            document.body.classList.remove('red-alert');
        }
        
        function addStrike() {
            strikes++;
            document.getElementById(`strike${strikes}`).classList.add('active');
            
            // Inspector appears after 5 strikes
            if (strikes >= 5) {
                triggerInspector();
            }
        }
        
        function triggerInspector() {
            inspectorActive = true;
            document.getElementById('inspectorWarning').style.display = 'block';
            document.body.classList.add('red-alert');
            
            // The Inspector (mushroom man) appears behind player
            setTimeout(() => {
                gameOver("The Inspector has claimed you. 5 mistakes were made.");
            }, 10000);
        }
        
        function triggerJumpscare() {
            const js = document.getElementById('jumpscare');
            js.classList.add('active');
            setTimeout(() => js.classList.remove('active'), 2000);
        }
        
        function spawnCustomer() {
            if (customers.length > 0 || shutterClosed) return;
            
            // Determine if anomaly (30% base + night modifier)
            const anomalyChance = 0.3 + (currentNight * 0.1) + (gameTime / 360);
            const isAnomaly = Math.random() < anomalyChance;
            
            let anomalyType = null;
            if (isAnomaly) {
                const types = Object.keys(ANOMALIES).filter(k => !ANOMALIES[k].safe && !ANOMALIES[k].special);
                anomalyType = types[Math.floor(Math.random() * types.length)];
            } else {
                // Safe customer
                const safeTypes = Object.keys(ANOMALIES).filter(k => ANOMALIES[k].safe);
                anomalyType = safeTypes[Math.floor(Math.random() * safeTypes.length)];
            }
            
            const customer = {
                isAnomaly: isAnomaly,
                anomalyType: anomalyType,
                patience: 45, // Seconds before leaving
                order: generateOrder(),
                mesh: null
            };
            
            customers.push(customer);
            currentOrder = customer;
            
            // Visual representation
            const geo = new THREE.CapsuleGeometry(0.4, 1.6, 4, 8);
            const mat = new THREE.MeshStandardMaterial({ 
                color: isAnomaly ? 0x330000 : 0x666666,
                emissive: isAnomaly ? 0xff0000 : 0x000000,
                emissiveIntensity: isAnomaly ? 0.3 : 0
            });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(0, 1, 8);
            scene.add(mesh);
            customer.mesh = mesh;
            
            // Show order ticket
            showOrderTicket(customer);
            
            // Audio cue for some anomalies
            if (ANOMALIES[anomalyType].detect === 'audio') {
                playAudioCue(anomalyType);
            }
        }
        
        function generateOrder() {
            const toppings = ['lettuce', 'tomato', 'pickle', 'onion'];
            const numToppings = Math.floor(Math.random() * 3) + 1;
            const orderToppings = [];
            for (let i = 0; i < numToppings; i++) {
                orderToppings.push(toppings[Math.floor(Math.random() * toppings.length)]);
            }
            return { toppings: orderToppings };
        }
        
        function showOrderTicket(customer) {
            const ticket = document.getElementById('orderTicket');
            const details = document.getElementById('orderDetails');
            
            ticket.style.display = 'block';
            let html = `<div style="margin-bottom: 15px; font-size: 22px; font-weight: bold;">Customer: ${ANOMALIES[customer.anomalyType]?.name || 'Regular'}</div>`;
            html += `<div style="margin-bottom: 10px;">Toppings:</div>`;
            customer.order.toppings.forEach(t => {
                html += `<div class="ticket-item"><span class="ticket-checkbox" id="check_${t}"></span> ${t.charAt(0).toUpperCase() + t.slice(1)}</div>`;
            });
            details.innerHTML = html;
        }
        
        function updateOrderTicket() {
            if (!preparedShawarma) return;
            // Check off items
            if (preparedShawarma.lavash) {
                // Mark lavash
            }
            if (preparedShawarma.meat) {
                // Mark meat
            }
            preparedShawarma.toppings.forEach(t => {
                const check = document.getElementById(`check_${t}`);
                if (check) check.classList.add('checked');
            });
        }
        
        function removeCustomer() {
            if (customers.length > 0) {
                scene.remove(customers[0].mesh);
                customers.shift();
                currentOrder = null;
                document.getElementById('orderTicket').style.display = 'none';
            }
        }
        
        function showNotification(text) {
            const notif = document.getElementById('notification');
            notif.textContent = text;
            notif.style.display = 'block';
            setTimeout(() => notif.style.display = 'none', 3000);
        }
        
        function playAudioCue(type) {
            // Simulate audio with visual text
            if (type === 'GIBBERISH') {
                showNotification("Customer: 'XJ-9 KLAATU BARADA'");
            } else if (type === 'DOPPELGANGER') {
                showNotification("Customer: 'Is it warm in here? This shawarma feels warm...'");
            } else if (type === 'HACKER') {
                showNotification("Customer: 'Hello [PLAYER]... I know your name...'");
            }
        }
        
        function updateGame() {
            if (isGameOver || !gameStarted) return;
            
            // Time progression (12AM to 6AM)
            gameTime += 0.03;
            const hours = Math.floor(gameTime / 60);
            const mins = Math.floor(gameTime % 60);
            const displayTime = `${12 + hours}:${mins.toString().padStart(2, '0')} AM`;
            document.getElementById('timeDisplay').textContent = displayTime;
            
            // Win condition
            if (gameTime >= 360) {
                winGame();
                return;
            }
            
            // Special events at 2AM
            if (Math.floor(gameTime) === 120 && !window.twoAMEvent) {
                window.twoAMEvent = true;
                triggerTwoAMEvent();
            }
            
            // Meat event (whispering)
            if (Math.random() < 0.0005 && !window.meatEventActive) {
                triggerMeatEvent();
            }
            
            // Power drain
            let drain = 0.015;
            if (equipmentOn.meat) drain += 0.025;
            if (inCameras) drain += 0.04;
            if (nightVision) drain += 0.02;
            power = Math.max(0, power - drain);
            
            const powerBar = document.getElementById('powerBar');
            powerBar.style.width = power + '%';
            document.getElementById('powerText').textContent = Math.floor(power) + '%';
            
            if (power <= 0) {
                gameOver("Power failure. The darkness consumed you.");
            }
            
            // Spawn customers
            if (Math.random() < 0.003 && customers.length === 0) {
                spawnCustomer();
            }
            
            // Update customers
            customers.forEach((c, i) => {
                c.patience -= 0.016;
                
                // Move closer
                if (c.mesh.position.z > 5.5) {
                    c.mesh.position.z -= 0.02;
                }
                
                // Anomaly behaviors
                if (c.isAnomaly && c.mesh) {
                    if (c.anomalyType === 'POLYCORIA') {
                        c.mesh.rotation.y += 0.1;
                    }
                    if (c.anomalyType === 'TWINS') {
                        // Shake effect
                        c.mesh.position.x = Math.sin(Date.now() * 0.01) * 0.1;
                    }
                }
                
                // Leave if patience runs out
                if (c.patience <= 0) {
                    if (!c.isAnomaly) {
                        showNotification("CUSTOMER LEFT - STRESS INCREASED");
                        addStrike();
                    }
                    removeCustomer();
                }
            });
            
            // Meat tornado animation
            if (window.meatTornado && equipmentOn.meat) {
                window.meatTornado.rotation.y += 0.02;
                
                // Pulsing effect during event
                if (window.meatEventActive) {
                    const pulse = Math.sin(Date.now() * 0.01) * 0.5 + 0.5;
                    window.meatLight.intensity = 0.5 + pulse;
                    window.meatTornado.children.forEach((child, idx) => {
                        if (idx > 0) { // Skip spit
                            child.material.emissiveIntensity = 0.5 + pulse;
                            child.material.color.setHex(0xff0000);
                        }
                    });
                }
            }
        }
        
        function triggerTwoAMEvent() {
            showNotification("‚ö† 2:00 AM - CHECK LIGHTS");
            window.mainLight.color.setHex(0xff0000);
            document.body.classList.add('red-alert');
            
            setTimeout(() => {
                if (!inspectorActive) {
                    window.mainLight.color.setHex(0xffaa77);
                    document.body.classList.remove('red-alert');
                    showNotification("LIGHTS STABILIZED");
                }
            }, 30000);
        }
        
        function triggerMeatEvent() {
            window.meatEventActive = true;
            showNotification("‚ö† THE MEAT IS WHISPERING... TURN OFF GRILL!");
            
            // If player doesn't turn off within 10 seconds, jumpscare
            setTimeout(() => {
                if (equipmentOn.meat && !window.meatSafe) {
                    triggerJumpscare();
                    gameOver("The meat consumed you.");
                }
            }, 10000);
        }
        
        function updateMovement() {
            if (!isLocked || inCameras || isHiding || isGameOver) return;
            
            const speed = keys['shift'] ? 0.12 : 0.06;
            const dx = Math.sin(player.rotation) * speed;
            const dz = Math.cos(player.rotation) * speed;
            
            let moveX = 0, moveZ = 0;
            
            if (keys['w']) { moveX -= dx; moveZ -= dz; }
            if (keys['s']) { moveX += dx; moveZ += dz; }
            if (keys['a']) { moveX -= dz; moveZ += dx; }
            if (keys['d']) { moveX += dz; moveZ -= dx; }
            
            // Collision bounds (Exact kiosk dimensions)
            const newX = player.x + moveX;
            const newZ = player.z + moveZ;
            
            if (newX > -4.8 && newX < 4.8) player.x = newX;
            if (newZ > -4.8 && newZ < 4.3) player.z = newZ;
            
            camera.position.x = player.x;
            camera.position.z = player.z;
            
            // Interaction check
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const intersects = raycaster.intersectObjects(scene.children, true);
            
            const prompt = document.getElementById('interactionPrompt');
            let foundInteractable = false;
            
            for (let hit of intersects) {
                if (hit.distance < 3 && hit.object.userData.name) {
                    prompt.textContent = `[E] ${hit.object.userData.name}`;
                    prompt.style.display = 'block';
                    foundInteractable = true;
                    break;
                }
            }
            
            if (!foundInteractable) prompt.style.display = 'none';
        }
        
        function gameOver(reason) {
            isGameOver = true;
            document.exitPointerLock();
            document.getElementById('gameOver').style.display = 'flex';
            document.getElementById('gameOverReason').textContent = reason;
        }
        
        function winGame() {
            isGameOver = true;
            document.exitPointerLock();
            document.getElementById('gameOver').style.display = 'flex';
            document.getElementById('gameOverTitle').textContent = "SHIFT COMPLETE";
            document.getElementById('gameOverTitle').style.color = "#00ff00";
            document.getElementById('gameOverReason').textContent = "You survived the night. The Inspector is watching...";
        }
        
        function animate() {
            requestAnimationFrame(animate);
            updateMovement();
            updateGame();
            renderer.render(scene, camera);
        }
        
        function startGame() {
            // Simulate loading
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('loadingScreen').style.display = 'flex';
            
            let progress = 0;
            const loadInterval = setInterval(() => {
                progress += Math.random() * 15;
                if (progress >= 100) {
                    progress = 100;
                    clearInterval(loadInterval);
                    setTimeout(() => {
                        document.getElementById('loadingScreen').style.display = 'none';
                        document.getElementById('gameUI').style.display = 'block';
                        gameStarted = true;
                        init();
                        document.body.requestPointerLock();
                    }, 500);
                }
                document.getElementById('loadingFill').style.width = progress + '%';
                document.getElementById('loadingText').textContent = 
                    progress < 30 ? "Loading textures..." : 
                    progress < 60 ? "Initializing anomaly detection..." : 
                    progress < 90 ? "Calibrating meat tornado..." : "Starting night shift...";
            }, 200);
        }
        
        window.addEventListener('resize', () => {
            if (camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        });
    </script>
</body>
</html>
