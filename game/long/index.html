<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shoot or Run - Browser FPS</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #000;
            color: #fff;
            overflow: hidden;
        }
        #app {
            position: absolute;
            width: 100vw;
            height: 100vh;
            min-width: 1024px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #ui, #camera, #weapon {
            position: absolute;
            min-width: 50%;
        }
        #ui { z-index: 2; }
        #weapon { z-index: 4; }
    </style>
</head>
<body>
    <div id="app">Loading..</div>
    <script>
        // Type definitions (as comments for reference)
        // All classes and interfaces converted to JavaScript
        
        // ===== UTILS =====
        function degreeToRadians(degree) {
            return ((degree * Math.PI) / 180) % (2 * Math.PI);
        }
        
        function radiansToDegrees(radians) {
            return (180 * radians) / Math.PI;
        }
        
        function angle(x1, y1, x2, y2) {
            const angleRadians = Math.atan2(y2 - y1, x2 - x1);
            const angleDegrees = angleRadians * (180 / Math.PI);
            return angleDegrees < 0 ? angleDegrees + 360 : angleDegrees;
        }
        
        function normalizeAngle(a) {
            return (a + 360) % 360;
        }
        
        function normalizeAngleInRad(a) {
            return (a + 2 * Math.PI) % (2 * Math.PI);
        }
        
        function minmax(value, min, max) {
            return Math.max(min, Math.min(value, max));
        }
        
        function distance(x1, y1, x2, y2) {
            return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
        }
        
        function lerp(from, to, percent) {
            const val = minmax(percent, 0, 1);
            return from + (to - from) * val;
        }
        
        // ===== COLOR UTILS =====
        function overlayColor(baseColor, overlayColor, coverageRatio) {
            if (baseColor.a === 0) return baseColor;
            const invCoverageRatio = 1 - coverageRatio;
            const effectiveAlpha = overlayColor.a * coverageRatio;
            return {
                r: baseColor.r * invCoverageRatio + overlayColor.r * effectiveAlpha,
                g: baseColor.g * invCoverageRatio + overlayColor.g * effectiveAlpha,
                b: baseColor.b * invCoverageRatio + overlayColor.b * effectiveAlpha,
                a: baseColor.a + overlayColor.a * coverageRatio * invCoverageRatio,
            };
        }
        
        function applyBrightness(color, lightLevel) {
            if (lightLevel === undefined) return color;
            return {
                r: Math.min(color.r * lightLevel, 255),
                g: Math.min(color.g * lightLevel, 255),
                b: Math.min(color.b * lightLevel, 255),
                a: color.a,
            };
        }
        
        // ===== GEOMETRY UTILS =====
        function distSquare(x, y, x2, y2) {
            return Math.pow(x - x2, 2) + Math.pow(y - y2, 2);
        }
        
        function getDistance(sx, sy, ex, ey) {
            return Math.sqrt(distSquare(sx, sy, ex, ey));
        }
        
        function getLineIntersectPoint(x1, y1, x2, y2, x3, y3, x4, y4) {
            if ((x1 === x2 && y1 === y2) || (x3 === x4 && y3 === y4)) return false;
            const denominator = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
            if (denominator === 0) return false;
            const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denominator;
            const ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denominator;
            if (ua < 0 || ua > 1 || ub < 0 || ub > 1) return false;
            return { x: x1 + ua * (x2 - x1), y: y1 + ua * (y2 - y1) };
        }
        
        function isLinesHasIntersections(x1, y1, x2, y2, x3, y3, x4, y4) {
            if ((x1 === x2 && y1 === y2) || (x3 === x4 && y3 === y4)) return false;
            const denominator = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
            if (denominator === 0) return false;
            const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denominator;
            const ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denominator;
            return !(ua < 0 || ua > 1 || ub < 0 || ub > 1);
        }
        
        function distToSegment(x, y, sx, sy, ex, ey) {
            const l2 = distSquare(sx, sy, ex, ey);
            if (l2 === 0) return getDistance(x, y, sx, sy);
            let t = ((x - sx) * (ex - sx) + (y - sy) * (ey - sy)) / l2;
            t = Math.max(0, Math.min(1, t));
            return getDistance(x, y, sx + t * (ex - sx), sy + t * (ey - sy));
        }
        
        function is2DPointInTriangle(pointX, pointY, triangleP1x, triangleP1y, triangleP2x, triangleP2y, triangleP3x, triangleP3y) {
            const a = (triangleP1x - pointX) * (triangleP2y - triangleP1y) - (triangleP2x - triangleP1x) * (triangleP1y - pointY);
            const b = (triangleP2x - pointX) * (triangleP3y - triangleP2y) - (triangleP3x - triangleP2x) * (triangleP2y - pointY);
            const c = (triangleP3x - pointX) * (triangleP1y - triangleP3y) - (triangleP1x - triangleP3x) * (triangleP3y - pointY);
            return (a >= 0 && b >= 0 && c >= 0) || (a <= 0 && b <= 0 && c <= 0);
        }
        
        function isSquareIntersectTriangle(sx, sy, sSize, t1x, t1y, t2x, t2y, t3x, t3y) {
            return (
                isLinesHasIntersections(sx, sy, sx + sSize, sy, t1x, t1y, t2x, t2y) ||
                isLinesHasIntersections(sx + sSize, sy, sx + sSize, sy + sSize, t2x, t2y, t3x, t3y) ||
                isLinesHasIntersections(sx + sSize, sy + sSize, sx, sy + sSize, t3x, t3y, t1x, t1y) ||
                isLinesHasIntersections(sx, sy + sSize, sx, sy, t1x, t1y, t2x, t2y) ||
                isLinesHasIntersections(sx, sy, sx + sSize, sy, t2x, t2y, t3x, t3y) ||
                isLinesHasIntersections(sx, sy, sx + sSize, sy + sSize, t3x, t3y, t1x, t1y) ||
                isLinesHasIntersections(sx + sSize, sy, sx + sSize, sy + sSize, t1x, t1y, t2x, t2y) ||
                isLinesHasIntersections(sx + sSize, sy + sSize, sx, sy + sSize, t2x, t2y, t3x, t3y) ||
                isLinesHasIntersections(sx + sSize, sy + sSize, sx, sy, t3x, t3y, t1x, t1y)
            );
        }
        
        // ===== IMAGE LOADING =====
        async function extractTextureBitmap(url) {
            const image = await loadImage(url);
            const imageData = await extractImageData(image);
            const colors = await extractColors(image.height, image.width, imageData.data);
            return {
                height: image.height,
                width: image.width,
                colors,
            };
        }
        
        async function loadImage(url) {
            return new Promise((resolve, reject) => {
                const element = document.createElement("img");
                element.crossOrigin = "anonymous";
                element.src = url;
                element.onerror = () => reject();
                element.onload = () => resolve(element);
            });
        }
        
        async function extractImageData(image) {
            const canvas = document.createElement("canvas");
            canvas.width = image.width;
            canvas.height = image.height;
            const context = canvas.getContext("2d");
            context.drawImage(image, 0, 0, image.width, image.height);
            return context.getImageData(0, 0, image.width, image.height);
        }
        
        async function extractColors(height, width, imageData) {
            const colors = [];
            for (let y = 0; y < height; y++) {
                const row = [];
                for (let x = 0; x < width; x++) {
                    const i = x * 4 + y * width * 4;
                    row.push({
                        r: imageData[i],
                        g: imageData[i + 1],
                        b: imageData[i + 2],
                        a: imageData[i + 3],
                    });
                }
                colors.push(row);
            }
            return colors;
        }
        
        // ===== WEBGL SETUP =====
        const vertexShaderSource = `
            attribute vec4 aVertexPosition;
            attribute vec2 aTextureCoord;
            varying highp vec2 vTextureCoord;
            void main(void) {
                gl_Position = aVertexPosition;
                vTextureCoord = aTextureCoord;
            }
        `;
        
        const fragmentShaderSource = `
            varying highp vec2 vTextureCoord;
            uniform sampler2D uSampler;
            void main(void) {
                gl_FragColor = texture2D(uSampler, vTextureCoord);
            }
        `;
        
        function createShaderProgram(gl) {
            const vertexShader = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vertexShader, vertexShaderSource);
            gl.compileShader(vertexShader);
            
            const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fragmentShader, fragmentShaderSource);
            gl.compileShader(fragmentShader);
            
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            
            return program;
        }
        
        function createBuffers(gl) {
            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            const positions = [-1.0, 1.0, 1.0, 1.0, -1.0, -1.0, 1.0, -1.0];
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
            
            const textureCoordBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, textureCoordBuffer);
            const textureCoordinates = [0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0];
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoordinates), gl.STATIC_DRAW);
            
            return {
                position: positionBuffer,
                textureCoord: textureCoordBuffer,
            };
        }
        
        function createTextureFromBuffer(gl, width, height, data) {
            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            return texture;
        }
        
        function setupWebGL(canvas, width, height) {
            const gl = canvas.getContext('webgl');
            if (!gl) throw new Error('WebGL not supported');
            gl.viewport(0, 0, width, height);
            const program = createShaderProgram(gl);
            const buffers = createBuffers(gl);
            return { gl, program, buffers };
        }
        
        // ===== CANVAS CLASSES =====
        class WebglCanvas {
            constructor({ id, width, height, style }) {
                const canvas = document.createElement("canvas");
                const setup = setupWebGL(canvas, width, height);
                this.setup = setup;
                this.width = width;
                this.height = height;
                this.element = canvas;
                this.element.width = width;
                this.element.height = height;
                if (id) this.element.id = id;
                if (style) this.element.setAttribute("style", style);
                this.buffer = new Uint8Array(width * height * 4);
            }
            
            clear() {
                this.setup.gl.clear(0);
                this.buffer.fill(0);
            }
            
            createBufferSnapshot() {}
            
            commitBufferSnapshot() {
                const { gl, program, buffers } = this.setup;
                const texture = createTextureFromBuffer(gl, this.width, this.height, this.buffer);
                const vertexPosition = gl.getAttribLocation(program, "aVertexPosition");
                const textureCoord = gl.getAttribLocation(program, "aTextureCoord");
                const uSampler = gl.getUniformLocation(program, "uSampler");
                
                gl.clearColor(0.0, 0.0, 0.0, 1.0);
                gl.clear(gl.COLOR_BUFFER_BIT);
                
                gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);
                gl.vertexAttribPointer(vertexPosition, 2, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(vertexPosition);
                
                gl.bindBuffer(gl.ARRAY_BUFFER, buffers.textureCoord);
                gl.vertexAttribPointer(textureCoord, 2, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(textureCoord);
                
                gl.useProgram(program);
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.uniform1i(uSampler, 0);
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            }
            
            drawPixel({ x, y, color }) {
                if (color.a === 0) return;
                const offset = 4 * (Math.floor(x) + Math.floor(y) * this.width);
                this.buffer[offset] = color.r;
                this.buffer[offset + 1] = color.g;
                this.buffer[offset + 2] = color.b;
                this.buffer[offset + 3] = color.a;
            }
            
            drawImage({ x, y, texture }) {
                for (let i = 0; i < texture.height; i++) {
                    for (let j = 0; j < texture.width; j++) {
                        const color = texture.colors[i][j];
                        if (color.a !== 0) {
                            this.drawPixel({ x: x + j, y: y + i, color });
                        }
                    }
                }
            }
            
            drawVerticalLine({ x, y1, y2, color }) {
                for (let y = y1; y < y2; y++) {
                    this.drawPixel({ x, y, color });
                }
            }
            
            drawRect({ x, y, width, height, color }) {
                const startX = minmax(x, 0, this.width);
                const startY = minmax(y, 0, this.width);
                const limitX = Math.min(this.width, x + width);
                const limitY = Math.min(this.height, y + height);
                for (let i = startX; i < limitX; i++) {
                    for (let j = startY; j < limitY; j++) {
                        this.drawPixel({ x: i, y: j, color });
                    }
                }
            }
        }
        
        class DefaultCanvas {
            constructor({ id, width, height, style, scale }) {
                this.width = width;
                this.height = height;
                this.element = document.createElement('canvas');
                if (id) this.element.id = id;
                this.element.width = width;
                this.element.height = height;
                if (style) this.element.setAttribute('style', style);
                this.context = this.element.getContext('2d');
                if (scale) this.context.scale(scale, scale);
            }
            
            drawBackground(color) {
                this.context.fillStyle = color;
                this.context.fillRect(0, 0, this.width, this.height);
            }
            
            drawVerticalLine({ x, y1, y2, color }) {
                this.context.fillStyle = color;
                this.context.fillRect(x, y1, 1, y2 - y1);
            }
            
            drawLine({ x1, y1, x2, y2, color }) {
                this.context.strokeStyle = color;
                this.context.beginPath();
                this.context.moveTo(x1, y1);
                this.context.lineTo(x2, y2);
                this.context.stroke();
            }
            
            drawRect({ x, y, width, height, color }) {
                this.context.fillStyle = color;
                this.context.fillRect(x, y, width, height);
            }
            
            drawPolygon({ paths, color }) {
                if (paths.length < 8) return;
                this.context.fillStyle = color;
                this.context.beginPath();
                this.context.moveTo(paths[0], paths[1]);
                for (let i = 2; i < paths.length - 1; i += 2) {
                    this.context.lineTo(paths[i], paths[i + 1]);
                }
                this.context.closePath();
                this.context.fill();
            }
            
            drawCircle({ x, y, radius, color }) {
                this.context.beginPath();
                this.context.arc(x, y, radius, 0, 2 * Math.PI);
                this.context.fillStyle = color;
                this.context.fill();
            }
            
            drawText({ x, y, color, font, text, align }) {
                if (align) this.context.textAlign = align;
                if (color) this.context.fillStyle = color;
                this.context.font = font;
                this.context.fillText(text, x, y);
            }
            
            clear() {
                this.context.clearRect(0, 0, this.width, this.height);
            }
        }
        
        // ===== ECS SYSTEM =====
        class ComponentContainer {
            constructor() {
                this.map = new Map();
            }
            
            add(component) {
                this.map.set(component.constructor, component);
            }
            
            get(componentClass) {
                return this.map.get(componentClass);
            }
            
            has(componentClass) {
                return this.map.has(componentClass);
            }
            
            all(componentClasses) {
                for (const componentClass of componentClasses) {
                    if (!this.map.has(componentClass)) return false;
                }
                return true;
            }
            
            delete(componentClass) {
                this.map.delete(componentClass);
            }
        }
        
        class ECS {
            constructor() {
                this.entities = new Map();
                this.systems = new Map();
                this.componentAddCallbacks = new Map();
                this.componentRemoveCallbacks = new Map();
                this.nextEntityID = 0;
                this.entitiesToDestroy = [];
            }
            
            start() {
                for (const system of this.systems.keys()) {
                    system.start();
                }
            }
            
            update(dt) {
                for (const [system, entities] of this.systems.entries()) {
                    system.update(dt, entities);
                }
                while (this.entitiesToDestroy.length > 0) {
                    this.destroyEntity(this.entitiesToDestroy.pop());
                }
            }
            
            destroy() {
                for (const system of this.systems.keys()) {
                    system.destroy();
                }
            }
            
            query(componentClasses) {
                const matchingEntities = new Set();
                for (const [entity, components] of this.entities.entries()) {
                    if (components.all(componentClasses)) {
                        matchingEntities.add(entity);
                    }
                }
                return matchingEntities;
            }
            
            addEntity() {
                const entity = this.nextEntityID;
                this.nextEntityID++;
                this.entities.set(entity, new ComponentContainer());
                return entity;
            }
            
            removeEntity(entity) {
                this.entitiesToDestroy.push(entity);
            }
            
            syncEntity(entity) {
                for (const system of this.systems.keys()) {
                    this.syncSystem(entity, system);
                }
            }
            
            destroyEntity(entity) {
                this.entities.delete(entity);
                for (const entities of this.systems.values()) {
                    entities.delete(entity);
                }
            }
            
            getComponents(entity) {
                return this.entities.get(entity);
            }
            
            addComponent(entity, component) {
                this.entities.get(entity)?.add(component);
                this.syncEntity(entity);
                this.componentAddCallbacks.get(component.constructor)?.forEach(cb => cb(entity));
            }
            
            onComponentAdd(componentClass, callback) {
                if (!this.componentAddCallbacks.has(componentClass)) {
                    this.componentAddCallbacks.set(componentClass, new Set());
                }
                this.componentAddCallbacks.get(componentClass)?.add(callback);
            }
            
            removeComponent(entity, componentClass) {
                this.entities.get(entity)?.delete(componentClass);
                this.syncEntity(entity);
                this.componentRemoveCallbacks.get(componentClass)?.forEach(cb => cb(entity));
            }
            
            onComponentRemove(componentClass, callback) {
                this.componentRemoveCallbacks.get(componentClass)?.delete(callback);
            }
            
            addSystem(system) {
                if (system.componentsRequired.size == 0) return;
                this.systems.set(system, new Set());
                for (const entity of this.entities.keys()) {
                    this.syncSystem(entity, system);
                }
            }
            
            getSystem(systemClass) {
                for (const system of this.systems.keys()) {
                    if (system instanceof systemClass) return system;
                }
            }
            
            syncSystem(entity, system) {
                const components = this.entities.get(entity);
                if (components) {
                    if (components.all(system.componentsRequired)) {
                        this.systems.get(system).add(entity);
                    } else {
                        this.systems.get(system).delete(entity);
                    }
                }
            }
            
            removeSystem(system) {
                this.systems.delete(system);
            }
        }
        
        class System {
            constructor(ecs) {
                this.ecs = ecs;
            }
        }
        
        // ===== COMPONENTS =====
        class PositionComponent {
            constructor(x = 0, y = 0) {
                this.x = x;
                this.y = y;
            }
        }
        
        class AngleComponent {
            constructor(angle = 0) {
                this.angle = angle;
            }
        }
        
        class MoveComponent {
            constructor(moveSpeed = 0, canSlide = false, mainDirection = 0, sideDirection = 0) {
                this.moveSpeed = moveSpeed;
                this.canSlide = canSlide;
                this.mainDirection = mainDirection;
                this.sideDirection = sideDirection;
            }
        }
        
        const MainDirection = { Back: -1, None: 0, Forward: 1 };
        const SideDirection = { Left: -1, None: 0, Right: 1 };
        
        class RotateComponent {
            constructor(rotationSpeed = 0) {
                this.rotationSpeed = rotationSpeed;
                this.rotationFactor = 0;
            }
        }
        
        class ControlComponent {}
        class PlayerComponent {
            constructor() {
                this.currentWeapon = null;
                this.weapons = {};
            }
        }
        
        class HealthComponent {
            constructor(maximum, current) {
                this.maximum = maximum;
                this.current = current;
            }
        }
        
        class CircleComponent {
            constructor(radius = 0) {
                this.radius = radius;
            }
        }
        
        class BoxComponent {
            constructor(size = 0) {
                this.size = size;
            }
        }
        
        class CameraComponent {
            constructor(fov = 0) {
                this.fov = fov;
            }
        }
        
        class MinimapComponent {
            constructor(color) {
                this.color = color;
            }
        }
        
        class TextureComponent {
            constructor(texture) {
                this.texture = texture;
            }
        }
        
        class SpriteComponent {
            constructor(sprite) {
                this.sprite = sprite;
            }
        }
        
        class AnimatedSpriteComponent {
            constructor(initialState, states) {
                this.states = states;
                this.currentFrame = 0;
                this.currentState = initialState;
                this.sprite = states[initialState][0];
                this.animationSpeed = 0.2;
                this.timeSinceLastFrame = 0;
                this.loop = false;
            }
            
            update(dt) {
                const frames = this.states[this.currentState];
                this.timeSinceLastFrame += dt;
                if (!this.loop && this.currentFrame === frames.length - 1) return;
                if (this.timeSinceLastFrame > this.animationSpeed) {
                    this.currentFrame = (this.currentFrame + 1) % frames.length;
                    this.sprite = frames[this.currentFrame];
                    this.timeSinceLastFrame = 0;
                }
            }
            
            switchState(stateName, loop) {
                if (this.currentState === stateName && loop == true) return;
                if (stateName in this.states) {
                    this.currentFrame = 0;
                    this.currentState = stateName;
                    this.loop = loop;
                }
            }
        }
        
        class WeaponComponent {
            constructor() {
                this.sprite = null;
            }
        }
        
        class WeaponMeleeComponent extends WeaponComponent {
            constructor(props) {
                super();
                const { attackDamage = 15, attackFrequency = 1000, sprite } = props;
                this.sprite = sprite;
                this.attackDamage = attackDamage;
                this.attackFrequency = attackFrequency;
                this.attackLastTimeAt = Date.now();
            }
        }
        
        class WeaponRangeComponent extends WeaponComponent {
            constructor(props) {
                super();
                const {
                    bulletSprite = '',
                    bulletTotal = 30,
                    bulletDamage = 15,
                    bulletSpeed = 5,
                    attackDistance = 4,
                    attackFrequency = 1000,
                    sprite
                } = props;
                this.bulletSprite = bulletSprite;
                this.bulletTotal = bulletTotal;
                this.bulletDamage = bulletDamage;
                this.bulletSpeed = bulletSpeed;
                this.attackDistance = attackDistance;
                this.attackFrequency = attackFrequency;
                this.attackLastTimeAt = Date.now();
                this.sprite = sprite;
            }
        }
        
        class BulletComponent {
            constructor(fromEntity, damage) {
                this.fromEntity = fromEntity;
                this.damage = damage;
                this.createdAt = Date.now();
            }
        }
        
        class CollisionComponent {
            constructor() {
                this.collidedEntity = null;
                this.isCollided = false;
            }
        }
        
        class EnemyComponent {}
        
        class AIComponent {
            constructor(activateDistance) {
                this.activateDistance = activateDistance;
                this.actionPassedTime = Infinity;
            }
        }
        
        class ItemComponent {
            constructor(type, value) {
                this.type = type;
                this.value = value;
            }
        }
        
        class DoorComponent {
            constructor(isOpened, isVertical) {
                this.isOpened = isOpened;
                this.isVertical = isVertical;
                this.animationTime = 1;
                this.offset = 0;
            }
        }
        
        class LightComponent {
            constructor(distance, brightness, isStaticLight = false, lightFn = 'linear') {
                this.distance = distance;
                this.brightness = brightness;
                this.isStaticLight = isStaticLight;
                const lightApplyFn = {
                    linear: (x) => x,
                    easeInOutCubic: (x) => x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 2, 3) / 2,
                    easeInQuart: (x) => x * x * x * x
                };
                this.lightFn = lightApplyFn[lightFn];
            }
        }
        
        class HighlightComponent {
            constructor(color, duration = 500) {
                this.startedAt = Date.now();
                this.color = color;
                this.duration = duration;
            }
        }
        
        // ===== POSITION MAP =====
        class PositionMap {
            constructor(levelMap) {
                this.cols = levelMap[0].length;
                this.rows = levelMap.length;
                this.map = new Map();
            }
            
            set(x, y, entity) {
                this.map.set(y * this.cols + x, entity);
            }
            
            get(x, y) {
                return this.map.get(y * this.cols + x);
            }
            
            has(x, y) {
                return this.map.has(y * this.cols + x);
            }
            
            reset(x, y) {
                return this.map.delete(y * this.cols + x);
            }
            
            clear() {
                this.map.clear();
            }
            
            toArray() {
                const list = [];
                for (let y = 0; y < this.rows; y++) {
                    const row = [];
                    for (let x = 0; x < this.cols; x++) {
                        row.push(this.get(x, y));
                    }
                    list.push(row);
                }
                return list;
            }
        }
        
        // ===== POLAR MAP =====
        class PolarMap {
            constructor() {
                this.center = null;
                this.entities = [];
                this.polarEntities = [];
            }
            
            select(distanceTo, angleFrom, angleTo) {
                angleFrom = normalizeAngle(angleFrom);
                angleTo = normalizeAngle(angleTo);
                return this.polarEntities
                    .filter((polarEntity) => {
                        if (distanceTo <= polarEntity.distance) return false;
                        const a1 = 0;
                        const a2 = normalizeAngle(polarEntity.angleTo - polarEntity.angleFrom);
                        const b1 = normalizeAngle(angleFrom - polarEntity.angleFrom);
                        const b2 = normalizeAngle(angleTo - polarEntity.angleFrom);
                        return a1 <= b1 && b1 <= a2 && a1 <= b2 && b2 <= a2;
                    })
                    .sort((pe1, pe2) => pe2.distance - pe1.distance);
            }
            
            calculatePolarEntities() {
                const centerPosition = this.center?.get(PositionComponent);
                if (!this.entities || !centerPosition) return;
                this.polarEntities = this.entities
                    .map((container) => {
                        const pointCircle = container.get(CircleComponent);
                        const pointPosition = container.get(PositionComponent);
                        const a = angle(centerPosition.x, centerPosition.y, pointPosition.x, pointPosition.y);
                        const d = distance(centerPosition.x, centerPosition.y, pointPosition.x, pointPosition.y);
                        const ta = Math.asin(pointCircle.radius / d) * (180 / Math.PI);
                        return {
                            distance: d,
                            angleFrom: normalizeAngle(a - ta),
                            angleTo: normalizeAngle(a + ta),
                            container,
                        };
                    })
                    .filter((polarEntity) => !isNaN(polarEntity.angleFrom));
            }
        }
        
        // ===== SCALED MAP =====
        class ScaledMap {
            constructor(width, height, scale = 1) {
                this.width = width;
                this.height = height;
                this.scale = scale;
                this.scaledWidth = Math.round(width * scale);
                this.scaledHeight = Math.round(height * scale);
                this.data = new Float64Array(this.scaledWidth * this.scaledHeight);
            }
            
            clean() {
                this.data.fill(0);
            }
            
            set(x, y, val) {
                const startY = Math.floor(y * this.scale);
                const endY = Math.ceil((y + 1) * this.scale);
                const startX = Math.floor(x * this.scale);
                const endX = Math.ceil((x + 1) * this.scale);
                for (let sy = startY; sy < endY; sy++) {
                    for (let sx = startX; sx < endX; sx++) {
                        this.data[sy * this.scaledWidth + sx] = Math.min(1, Math.max(0, val));
                    }
                }
            }
            
            get(x, y) {
                const sx = Math.floor(x * this.scale);
                const sy = Math.floor(y * this.scale);
                const idx = sy * this.scaledWidth + sx;
                return idx >= 0 && idx < this.data.length ? this.data[idx] : 0;
            }
            
            setScaled(x, y, val) {
                const idx = Math.floor(y * this.scaledWidth + x);
                if (idx >= 0 && idx < this.data.length) {
                    this.data[idx] = Math.min(1, Math.max(0, val));
                }
            }
            
            getScaled(x, y) {
                const idx = Math.floor(y * this.scaledWidth + x);
                return idx >= 0 && idx < this.data.length ? this.data[idx] : 0;
            }
            
            getInPercents(px, py) {
                const x = (px * this.scaledWidth) | 0;
                const y = (py * this.scaledHeight) | 0;
                const idx = y * this.scaledWidth + x;
                if (idx >= 0 && idx < this.data.length) return this.data[idx];
                return 0;
            }
        }
        
        // ===== LIGHT CASTING =====
        class LightCasting2D {
            constructor(radius, quality = 20, bendOffset = 0) {
                this.radius = radius;
                this.vecEdges = [];
                this.vecVisibilityPolygonPoints = [];
                this.lightMap = new ScaledMap(radius * 2, radius * 2, quality);
                this.world = [];
                this.worldEdges = [];
                this.emitterPosition = { x: 0, y: 0 };
                this.boundingBox = { ex: 0, ey: 0, sx: 0, sy: 0 };
                this.bendOffset = bendOffset;
            }
            
            calculateVisibilityPolygon(ox, oy) {
                this.emitterPosition = { x: ox, y: oy };
                this.boundingBox = {
                    sx: this.emitterPosition.x - this.radius,
                    sy: this.emitterPosition.y - this.radius,
                    ex: this.emitterPosition.x + this.radius,
                    ey: this.emitterPosition.y + this.radius,
                };
                this.vecVisibilityPolygonPoints = [];
                const countRadialRays = 40;
                const pointToLineDistance = 0.01;
                const joinPointsDistance = 0.01;
                
                for (let i = 0; i <= countRadialRays; i++) {
                    const ang = -Math.PI + (i * Math.PI * 2) / countRadialRays;
                    const current = this.castLightRay(ox, oy, ang, this.radius);
                    const prev2 = this.vecVisibilityPolygonPoints[this.vecVisibilityPolygonPoints.length - 2];
                    const prev = this.vecVisibilityPolygonPoints[this.vecVisibilityPolygonPoints.length - 1];
                    
                    if (prev2 && prev && getDistanceFrom2DPointToLine(current.x, current.y, prev2.x, prev2.y, prev.x, prev.y) <= pointToLineDistance) {
                        prev.x = current.x;
                        prev.y = current.y;
                    } else {
                        this.vecVisibilityPolygonPoints.push(current);
                    }
                }
                
                for (let i = 0; i < this.vecEdges.length - 1; i += 4) {
                    const sx = this.vecEdges[i];
                    const sy = this.vecEdges[i + 1];
                    const ex = this.vecEdges[i + 2];
                    const ey = this.vecEdges[i + 3];
                    const bothOfEdgePointsOutOfDistance = distToSegment(ox, oy, sx, sy, ex, ey) > this.radius;
                    if (bothOfEdgePointsOutOfDistance) continue;
                    
                    for (let i = 0; i < 2; i++) {
                        const rdx = (i === 0 ? sx : ex) - ox;
                        const rdy = (i === 0 ? sy : ey) - oy;
                        let ang = 0;
                        const base_ang = Math.atan2(rdy, rdx);
                        
                        for (let j = 0; j < 3; j++) {
                            const delta = 0.001;
                            if (j === 0) ang = base_ang - delta;
                            if (j === 1) ang = base_ang;
                            if (j === 2) ang = base_ang + delta;
                            
                            const vec = this.castLightRay(ox, oy, ang, this.radius);
                            this.vecVisibilityPolygonPoints.push(vec);
                        }
                    }
                }
                
                this.vecVisibilityPolygonPoints.sort((p1, p2) => p1.ang < p2.ang ? -1 : 1);
                
                const uniqVecVisibilityPolygonPoints = [];
                for (let i = 0; i < this.vecVisibilityPolygonPoints.length - 1; i++) {
                    const prev = this.vecVisibilityPolygonPoints[i - 1];
                    const current = this.vecVisibilityPolygonPoints[i];
                    let next = this.vecVisibilityPolygonPoints[i + 1];
                    uniqVecVisibilityPolygonPoints.push(current);
                    
                    let isClosePoint = Math.abs(current.x - next.x) < joinPointsDistance && Math.abs(current.y - next.y) < joinPointsDistance;
                    while (next && isClosePoint) {
                        i++;
                        next = this.vecVisibilityPolygonPoints[i + 1];
                        isClosePoint = next && Math.abs(current.x - next.x) < joinPointsDistance && Math.abs(current.y - next.y) < joinPointsDistance;
                    }
                    
                    let nextPointOnCurrentLine = prev && current && next && getDistanceFrom2DPointToLine(next.x, next.y, prev.x, prev.y, current.x, current.y) <= joinPointsDistance;
                    while (nextPointOnCurrentLine) {
                        current.x = next.x;
                        current.y = next.y;
                        i++;
                        next = this.vecVisibilityPolygonPoints[i + 1];
                        nextPointOnCurrentLine = prev && current && next && getDistanceFrom2DPointToLine(next.x, next.y, prev.x, prev.y, current.x, current.y) <= joinPointsDistance;
                    }
                }
                this.vecVisibilityPolygonPoints = uniqVecVisibilityPolygonPoints;
                this.vecVisibilityPolygonPoints.push({
                    x: this.vecVisibilityPolygonPoints[0].x,
                    y: this.vecVisibilityPolygonPoints[0].y,
                    ang: this.vecVisibilityPolygonPoints[0].ang + Math.PI * 2,
                });
                
                this.fillLightMap(ox, oy);
            }
            
            fillLightMap(ox, oy) {
                this.lightMap.clean();
                const mapStartX = ox - this.radius;
                const mapStartY = oy - this.radius;
                const radiusInLightMap = this.lightMap.scaledWidth / 2;
                
                for (let i = 0; i < this.vecVisibilityPolygonPoints.length - 1; i++) {
                    const current = this.vecVisibilityPolygonPoints[i];
                    const next = this.vecVisibilityPolygonPoints[i + 1];
                    const minX = Math.floor((Math.min(ox, current.x, next.x) - mapStartX) * this.lightMap.scale);
                    const minY = Math.floor((Math.min(oy, current.y, next.y) - mapStartY) * this.lightMap.scale);
                    const maxX = Math.floor((Math.max(ox, current.x, next.x) - mapStartX) * this.lightMap.scale - 0.0001);
                    const maxY = Math.floor((Math.max(oy, current.y, next.y) - mapStartY) * this.lightMap.scale - 0.0001);
                    
                    for (let x = minX; x <= maxX; x++) {
                        for (let y = minY; y <= maxY; y++) {
                            if (this.lightMap.getScaled(x, y) > 0) continue;
                            const isPointInTriangle = is2DPointInTriangle(x + 0.5, y + 0.5, radiusInLightMap, radiusInLightMap, (current.x - mapStartX) * this.lightMap.scale, (current.y - mapStartY) * this.lightMap.scale, (next.x - mapStartX) * this.lightMap.scale, (next.y - mapStartY) * this.lightMap.scale);
                            if (isPointInTriangle) {
                                this.lightMap.setScaled(x, y, 1 - getDistance(x + 0.5, y + 0.5, radiusInLightMap, radiusInLightMap) / (radiusInLightMap + 1));
                            }
                            const isInSquare = isSquareIntersectTriangle(x, y, 1, radiusInLightMap, radiusInLightMap, (current.x - mapStartX) * this.lightMap.scale, (current.y - mapStartY) * this.lightMap.scale, (next.x - mapStartX) * this.lightMap.scale, (next.y - mapStartY) * this.lightMap.scale);
                            if (isInSquare) {
                                this.lightMap.setScaled(x, y, 1 - getDistance(x + 0.5, y + 0.5, radiusInLightMap, radiusInLightMap) / (radiusInLightMap + 1));
                            }
                        }
                    }
                }
            }
            
            castLightRay(ox, oy, ang, distance) {
                const rdx = distance * Math.cos(ang);
                const rdy = distance * Math.sin(ang);
                const closestPoint = { ang: ang, x: ox + rdx, y: oy + rdy, magnitude: distance };
                const pointAfterClosest = { ang: ang, x: ox + rdx, y: oy + rdy, magnitude: distance };
                
                for (let i = 0; i < this.vecEdges.length - 1; i += 4) {
                    const sx = this.vecEdges[i];
                    const sy = this.vecEdges[i + 1];
                    const ex = this.vecEdges[i + 2];
                    const ey = this.vecEdges[i + 3];
                    const bothOfEdgePointsOutOfDistance = distToSegment(ox, oy, sx, sy, ex, ey) > distance;
                    if (bothOfEdgePointsOutOfDistance) continue;
                    
                    const intersection = getLineIntersectPoint(sx, sy, ex, ey, ox, oy, ox + rdx, oy + rdy);
                    if (!intersection) continue;
                    
                    const magnitude = getDistance(intersection.x, intersection.y, ox, oy);
                    if (magnitude < closestPoint.magnitude) {
                        pointAfterClosest.magnitude = closestPoint.magnitude;
                        pointAfterClosest.ang = closestPoint.ang;
                        pointAfterClosest.x = closestPoint.x;
                        pointAfterClosest.y = closestPoint.y;
                        closestPoint.magnitude = magnitude;
                        closestPoint.ang = Math.atan2(intersection.y - oy, intersection.x - ox);
                        closestPoint.x = intersection.x;
                        closestPoint.y = intersection.y;
                    } else if (magnitude < pointAfterClosest.magnitude) {
                        pointAfterClosest.magnitude = magnitude;
                        pointAfterClosest.ang = Math.atan2(intersection.y - oy, intersection.x - ox);
                        pointAfterClosest.x = intersection.x;
                        pointAfterClosest.y = intersection.y;
                    }
                }
                
                const offsetPart = this.bendOffset;
                return {
                    ang: closestPoint.ang,
                    x: (pointAfterClosest.x - closestPoint.x) * offsetPart + closestPoint.x,
                    y: (pointAfterClosest.y - closestPoint.y) * offsetPart + closestPoint.y,
                    magnitude: (pointAfterClosest.magnitude - closestPoint.magnitude) * offsetPart,
                };
            }
            
            checkPointInBoundingBox(x, y) {
                const { ex, ey, sx, sy } = this.boundingBox;
                return x - 0.0001 < sx || x + 0.0001 > ex || y - 0.0001 < sy || y + 0.0001 > ey;
            }
            
            getLightLevelInPoint(x, y) {
                if (this.checkPointInBoundingBox(x, y)) return 0;
                return this.lightMap.getInPercents((x - this.boundingBox.sx) / this.lightMap.width, (y - this.boundingBox.sy) / this.lightMap.height);
            }
        }
        
        function getDistanceFrom2DPointToLine(pointX, pointY, pointOnLineX, pointOnLineY, anotherPointOnLineX, anotherPointOnLineY) {
            const A = anotherPointOnLineY - pointOnLineY;
            const B = pointOnLineX - anotherPointOnLineX;
            const C = anotherPointOnLineX * pointOnLineY - pointOnLineX * anotherPointOnLineY;
            return Math.abs(A * pointX + B * pointY + C) / Math.sqrt(A * A + B * B);
        }
        
        // ===== SYSTEMS =====
        class MapTextureSystem extends System {
            constructor(ecs, level) {
                super(ecs);
                this.componentsRequired = new Set([PositionComponent, TextureComponent]);
                this.textureMap = new PositionMap(level.map);
            }
            
            start() {
                this.ecs.query([PositionComponent, TextureComponent]).forEach((entity) => {
                    const container = this.ecs.getComponents(entity);
                    const position = container.get(PositionComponent);
                    this.textureMap.set(Math.floor(position.x), Math.floor(position.y), container);
                });
                
                this.ecs.onComponentAdd(PositionComponent, (entity) => {
                    const container = this.ecs.getComponents(entity);
                    const position = container.get(PositionComponent);
                    if (!container.has(TextureComponent)) return;
                    this.textureMap.set(Math.floor(position.x), Math.floor(position.y), container);
                });
                
                this.ecs.onComponentRemove(PositionComponent, (entity) => {
                    const container = this.ecs.getComponents(entity);
                    const position = container.get(PositionComponent);
                    if (!container.has(TextureComponent)) return;
                    this.textureMap.reset(Math.floor(position.x), Math.floor(position.y));
                });
            }
            
            update() {}
            destroy() {}
        }
        
        class MapPolarSystem extends System {
            constructor(ecs) {
                super(ecs);
                this.componentsRequired = new Set([PositionComponent]);
                this.polarMap = new PolarMap();
            }
            
            start() {}
            
            update(_, entities) {
                const [player] = this.ecs.query([PlayerComponent, CircleComponent, PositionComponent]);
                const spriteContainers = [];
                for (const entity of entities) {
                    if (this.ecs.getComponents(entity).has(AnimatedSpriteComponent) || this.ecs.getComponents(entity).has(SpriteComponent)) {
                        spriteContainers.push(this.ecs.getComponents(entity));
                    }
                }
                this.polarMap.center = this.ecs.getComponents(player);
                this.polarMap.entities = spriteContainers;
                this.polarMap.calculatePolarEntities();
            }
            
            destroy() {}
        }
        
        class MoveSystem extends System {
            constructor(ecs) {
                super(ecs);
                this.componentsRequired = new Set([PositionComponent, AngleComponent, MoveComponent, CollisionComponent]);
            }
            
            start() {}
            destroy() {}
            
            update(dt, entities) {
                entities.forEach((entity) => this.move(dt, entity));
            }
            
            move(dt, entity) {
                const components = this.ecs.getComponents(entity);
                const angleComponent = components.get(AngleComponent);
                const positionComponent = components.get(PositionComponent);
                const collisionComponent = components.get(CollisionComponent);
                const moveComponent = components.get(MoveComponent);
                
                const m = Number(moveComponent.mainDirection);
                const s = Number(moveComponent.sideDirection) * -1;
                
                if (m || s) {
                    const mainAngle = degreeToRadians(angleComponent.angle - 360);
                    const mainCos = Math.cos(mainAngle);
                    const mainSin = Math.sin(mainAngle);
                    const sideAngle = degreeToRadians(angleComponent.angle - 90);
                    const sideCos = Math.cos(sideAngle);
                    const sideSin = Math.sin(sideAngle);
                    
                    let newX = positionComponent.x + (m * mainCos + s * sideCos) * moveComponent.moveSpeed * dt;
                    let newY = positionComponent.y + (m * mainSin + s * sideSin) * moveComponent.moveSpeed * dt;
                    
                    const { collidedX, collidedY, collidedWith } = this.getCollision(positionComponent, new PositionComponent(newX, newY));
                    const hasCollision = collidedX || collidedY;
                    
                    if (!hasCollision) {
                        positionComponent.x = newX;
                        positionComponent.y = newY;
                        return;
                    }
                    
                    if (collidedWith) {
                        collisionComponent.collidedEntity = collidedWith;
                        collisionComponent.isCollided = true;
                    }
                    
                    if (moveComponent.canSlide) {
                        if (!collidedX) positionComponent.x = newX;
                        else newX = positionComponent.x;
                        if (!collidedY) positionComponent.y = newY;
                        else newY = positionComponent.y;
                        positionComponent.x = newX;
                        positionComponent.y = newY;
                    }
                }
            }
            
            getCollision(currentPos, nexPos) {
                const textureMap = this.ecs.getSystem(MapTextureSystem).textureMap;
                let collidedWith = null;
                let collidedX = false;
                let collidedY = false;
                
                if (nexPos.x <= 0 || nexPos.x > textureMap.cols) collidedX = true;
                
                const collideWithTextureByX = textureMap.get(Math.floor(nexPos.x), Math.floor(currentPos.y));
                if (collideWithTextureByX && this.isCollidedEntity(collideWithTextureByX)) {
                    collidedX = true;
                    collidedWith = collideWithTextureByX;
                }
                
                if (nexPos.y <= 0 || nexPos.y > textureMap.rows) collidedY = true;
                
                const collideWithTextureByY = textureMap.get(Math.floor(currentPos.x), Math.floor(nexPos.y));
                if (collideWithTextureByY && this.isCollidedEntity(collideWithTextureByY)) {
                    collidedY = true;
                    collidedWith = collideWithTextureByY;
                }
                
                return { collidedX, collidedY, collidedWith };
            }
            
            isCollidedEntity(entityContainer) {
                const doorCmp = entityContainer.get(DoorComponent);
                if (doorCmp) return !doorCmp.isOpened;
                return true;
            }
        }
        
        class RotateSystem extends System {
            constructor(ecs) {
                super(ecs);
                this.componentsRequired = new Set([AngleComponent, RotateComponent]);
            }
            
            start() {}
            destroy() {}
            
            update(dt, entities) {
                entities.forEach((entity) => {
                    const components = this.ecs.getComponents(entity);
                    const angleComponent = components.get(AngleComponent);
                    const { rotationFactor, rotationSpeed } = components.get(RotateComponent);
                    angleComponent.angle = normalizeAngle(angleComponent.angle + rotationFactor * rotationSpeed * dt);
                });
            }
        }
        
        class ControlSystem extends System {
            constructor(ecs, container) {
                super(ecs);
                this.componentsRequired = new Set([ControlComponent, MoveComponent, RotateComponent, PlayerComponent]);
                this.container = container;
                this.direction = { up: false, down: false, left: false, right: false };
                this.lastActiveWeapon = 0;
                this.rotationFactor = 0;
                this.isPointerLocked = false;
                
                this.directionKeyCodes = { KeyW: "up", KeyS: "down", KeyA: "left", KeyD: "right" };
                this.weaponKeyCodes = { Digit1: 1, Digit2: 2, Digit3: 3, Digit4: 4 };
            }
            
            start() {
                this.createListeners();
                this.requestPointerLock();
            }
            
            update(_, entities) {
                entities.forEach((entity) => {
                    const componentContainer = this.ecs.getComponents(entity);
                    const playerComponent = componentContainer.get(PlayerComponent);
                    const rotateComponent = componentContainer.get(RotateComponent);
                    const moveComponent = componentContainer.get(MoveComponent);
                    
                    rotateComponent.rotationFactor = this.rotationFactor;
                    
                    if (this.direction.up) moveComponent.mainDirection = MainDirection.Forward;
                    else if (this.direction.down) moveComponent.mainDirection = MainDirection.Back;
                    else moveComponent.mainDirection = MainDirection.None;
                    
                    if (this.direction.left) moveComponent.sideDirection = SideDirection.Left;
                    else if (this.direction.right) moveComponent.sideDirection = SideDirection.Right;
                    else moveComponent.sideDirection = SideDirection.None;
                    
                    if (playerComponent.weapons[this.lastActiveWeapon] && playerComponent.currentWeapon !== playerComponent.weapons[this.lastActiveWeapon]) {
                        playerComponent.currentWeapon = playerComponent.weapons[this.lastActiveWeapon];
                    }
                });
                
                this.rotationFactor = 0;
            }
            
            destroy() {
                document.exitPointerLock();
                this.destroyListeners();
            }
            
            setDirection = (keyCode, status) => {
                const direction = this.directionKeyCodes[keyCode];
                if (!direction) return;
                this.direction[direction] = status;
            };
            
            setWeapon = (keyCode) => {
                const weaponCode = this.weaponKeyCodes[keyCode];
                if (!weaponCode) return;
                this.lastActiveWeapon = weaponCode;
            };
            
            handleDocumentKeyDown = (e) => {
                this.setDirection(e.code, true);
                this.setWeapon(e.code);
            };
            
            handleDocumentKeyUp = (e) => {
                this.setDirection(e.code, false);
            };
            
            handleDocumentMouseMove = (e) => {
                this.rotationFactor = e.movementX;
            };
            
            handlePointerLockChange = () => {
                if (this.isPointerLocked) {
                    document.addEventListener("mousemove", this.handleDocumentMouseMove);
                } else {
                    document.removeEventListener("mousemove", this.handleDocumentMouseMove);
                }
                this.isPointerLocked = !this.isPointerLocked;
            };
            
            requestPointerLock = () => {
                this.container.requestPointerLock();
                this.isPointerLocked = true;
            };
            
            createListeners() {
                document.addEventListener("keydown", this.handleDocumentKeyDown);
                document.addEventListener("keyup", this.handleDocumentKeyUp);
                document.addEventListener("pointerlockchange", this.handlePointerLockChange);
                this.container.addEventListener("click", this.requestPointerLock);
            }
            
            destroyListeners() {
                document.removeEventListener("keydown", this.handleDocumentKeyDown);
                document.removeEventListener("keyup", this.handleDocumentKeyUp);
                document.removeEventListener("pointerlockchange", this.handlePointerLockChange);
                this.container.removeEventListener("click", this.requestPointerLock);
            }
        }
        
        class AnimationSystem extends System {
            constructor(ecs) {
                super(ecs);
                this.componentsRequired = new Set([AnimatedSpriteComponent]);
            }
            
            start() {}
            
            update(dt, entities) {
                entities.forEach((entity) => {
                    this.ecs.getComponents(entity).get(AnimatedSpriteComponent).update(dt);
                });
            }
            
            destroy() {}
        }
        
        class DoorsSystem extends System {
            constructor(ecs) {
                super(ecs);
                this.componentsRequired = new Set([DoorComponent]);
                this.doorsAnimations = new Map();
            }
            
            start() {}
            destroy() {}
            
            update(dt, entities) {
                const [player] = this.ecs.query([PlayerComponent]);
                const playerContainer = this.ecs.getComponents(player);
                if (!playerContainer) return;
                
                const playerPosition = playerContainer.get(PositionComponent);
                
                entities.forEach((entity) => {
                    const components = this.ecs.getComponents(entity);
                    const door = components.get(DoorComponent);
                    const doorBox = components.get(BoxComponent);
                    const doorPosition = components.get(PositionComponent);
                    
                    if (!door || !doorPosition) return;
                    
                    const anim = this.doorsAnimations.get(entity);
                    if (anim) {
                        if (anim.remainingAnimationTime <= 0) {
                            this.doorsAnimations.delete(entity);
                            door.isOpened = !door.isOpened;
                            door.offset = door.isOpened ? doorBox.size : 0;
                            return;
                        }
                        
                        const offset = (dt / door.animationTime) * doorBox.size;
                        const axisOffset = door.isOpened ? -offset : offset;
                        door.offset += axisOffset;
                        anim.remainingAnimationTime = anim.remainingAnimationTime - dt;
                    } else {
                        const toPlayerDistance = distance(playerPosition.x, playerPosition.y, doorPosition.x, doorPosition.y);
                        
                        if ((!door.isOpened && toPlayerDistance < 1.5) || (door.isOpened && toPlayerDistance > 2.5)) {
                            this.doorsAnimations.set(entity, { remainingAnimationTime: door.animationTime });
                        }
                    }
                });
            }
        }
        
        class LightSystem extends System {
            constructor(ecs) {
                super(ecs);
                this.componentsRequired = new Set([LightComponent]);
                this.lastUpdateTime = 0;
                this.updatePerSecond = 30;
                this.quality = 16;
                this.globalLightLevel = 0.1;
                this.lightBias = 0.01;
                this.existedLights = new Set();
                this.listOfLightnings = [];
            }
            
            start() {
                this.ecs.onComponentAdd(LightComponent, (entity) => {
                    const light = this.ecs.getComponents(entity).get(LightComponent);
                    const pos = this.ecs.getComponents(entity).get(PositionComponent);
                    this.listOfLightnings.push({
                        entity,
                        cmp: light,
                        lightCasting: new LightCasting2D(light.distance, this.quality),
                        pos,
                    });
                    this.existedLights.add(entity);
                });
                
                this.ecs.onComponentRemove(LightComponent, (entity) => {
                    this.existedLights.delete(entity);
                    this.listOfLightnings = this.listOfLightnings.filter((lightCastingInstance) => lightCastingInstance.entity !== entity);
                });
            }
            
            destroy() {
                this.listOfLightnings.length = 0;
            }
            
            update(_, entities) {
                for (const entity of entities) {
                    if (this.existedLights.has(entity)) continue;
                    const lightCmp = this.ecs.getComponents(entity).get(LightComponent);
                    const pos = this.ecs.getComponents(entity).get(PositionComponent);
                    this.listOfLightnings.push({
                        entity,
                        cmp: lightCmp,
                        lightCasting: new LightCasting2D(lightCmp.distance, this.quality),
                        pos,
                    });
                    this.existedLights.add(entity);
                }
                
                if (Date.now() - this.lastUpdateTime > 1000 / this.updatePerSecond) {
                    this.lastUpdateTime = Date.now();
                    for (let i = 0; i < this.listOfLightnings.length; i++) {
                        this.listOfLightnings[i].pos = this.ecs.getComponents(this.listOfLightnings[i].entity).get(PositionComponent);
                        this.updateLight(this.listOfLightnings[i].lightCasting, this.ecs.getComponents(this.listOfLightnings[i].entity));
                    }
                }
            }
            
            updateLight(lightCastingInstance, container) {
                const lightCmp = container.get(LightComponent);
                if (!lightCmp.isStaticLight || lightCastingInstance.worldEdges.length === 0) {
                    const renderSystem = this.ecs.getSystem(RenderSystem);
                    const map = this.ecs.getSystem(MapTextureSystem).textureMap;
                    lightCastingInstance.vecEdges = map.toArray().flatMap((el) =>
                        el.flatMap((mapEntity) => {
                            if (!mapEntity) return [];
                            const renderer = renderSystem.mapEntityRenders.find((render) => render.canRender(mapEntity));
                            if (!renderer) return [];
                            return renderer.getArmature(mapEntity);
                        })
                    );
                }
                if (!lightCmp.isStaticLight || lightCastingInstance.vecVisibilityPolygonPoints.length === 0) {
                    const positionCmp = container.get(PositionComponent);
                    lightCastingInstance.calculateVisibilityPolygon(positionCmp.x, positionCmp.y);
                }
            }
            
            getLightingLevelForPoint(x, y) {
                let finalLightLevel = this.globalLightLevel;
                for (let i = 0; i < this.listOfLightnings.length; i++) {
                    const val = this.listOfLightnings[i];
                    const lightPower = val.lightCasting.getLightLevelInPoint(x + (val.pos.x - x) * this.lightBias, y + (val.pos.y - y) * this.lightBias);
                    const lightLevel = val.cmp.brightness * val.cmp.lightFn(lightPower);
                    finalLightLevel += lightLevel;
                }
                return finalLightLevel;
            }
        }
        
        // ===== RENDER SYSTEM =====
        class WallRender {
            canRender(mapEntity) {
                return mapEntity.has(TextureComponent);
            }
            
            getArmature(mapEntity) {
                const pos = mapEntity.get(PositionComponent);
                return [pos.x, pos.y, pos.x + 1, pos.y, pos.x, pos.y, pos.x, pos.y + 1, pos.x + 1, pos.y + 1, pos.x, pos.y + 1, pos.x + 1, pos.y + 1, pos.x + 1, pos.y];
            }
            
            render(mapEntity, screenHeight, _rayAngle, side, _sideDistX, _sideDistY, _deltaDistX, _deltaDistY, mapX, mapY, playerPos, stepX, stepY, rayDirX, rayDirY, fishEyeFixCoef) {
                const perpWallDist = side === 0 ? (mapX - playerPos.x + (1 - stepX) / 2) / rayDirX : (mapY - playerPos.y + (1 - stepY) / 2) / rayDirY;
                const correctedDist = perpWallDist * fishEyeFixCoef;
                const wallHeight = Math.floor(screenHeight / 2 / correctedDist);
                const rayX = playerPos.x + rayDirX * perpWallDist;
                const rayY = playerPos.y + rayDirY * perpWallDist;
                const texture = mapEntity.get(TextureComponent).texture;
                const texturePositionX = Math.floor((texture.width * (rayX + rayY)) % texture.width);
                
                return {
                    texturePositionX: texturePositionX,
                    texture: texture,
                    entityHeight: wallHeight,
                    rayX,
                    rayY,
                    distance: correctedDist,
                };
            }
        }
        
        class DoorRender {
            constructor() {
                this.doorWidth = 0.1;
            }
            
            canRender(mapEntity) {
                return mapEntity.all([TextureComponent, DoorComponent]);
            }
            
            getArmature(mapEntity) {
                const pos = mapEntity.get(PositionComponent);
                const door = mapEntity.get(DoorComponent);
                const halfDoorWidth = this.doorWidth / 2;
                
                if (!door.isVertical) {
                    return [
                        pos.x + door.offset, pos.y + 0.5 - halfDoorWidth, pos.x + 1, pos.y + 0.5 - halfDoorWidth,
                        pos.x + door.offset, pos.y + 0.5 + halfDoorWidth, pos.x + 1, pos.y + 0.5 + halfDoorWidth,
                        pos.x + door.offset, pos.y + 0.5 - halfDoorWidth, pos.x + door.offset, pos.y + 0.5 + halfDoorWidth,
                        pos.x + 1, pos.y + 0.5 - halfDoorWidth, pos.x + 1, pos.y + 0.5 + halfDoorWidth,
                    ];
                }
                return [
                    pos.x + 0.5 - halfDoorWidth, pos.y + door.offset, pos.x + 0.5 + halfDoorWidth, pos.y + door.offset,
                    pos.x + 0.5 - halfDoorWidth, pos.y + 1, pos.x + 0.5 + halfDoorWidth, pos.y + 1,
                    pos.x + 0.5 - halfDoorWidth, pos.y + door.offset, pos.x + 0.5 - halfDoorWidth, pos.y + 1,
                    pos.x + 0.5 + halfDoorWidth, pos.y + door.offset, pos.x + 0.5 + halfDoorWidth, pos.y + 1,
                ];
            }
            
            render(mapEntity, screenHeight, rayAngle, side, sideDistX, sideDistY, deltaDistX, deltaDistY, mapX, mapY, playerPos, stepX, stepY, rayDirX, rayDirY, fishEyeFixCoef) {
                const doorCmp = mapEntity.get(DoorComponent);
                const doorPosition = mapEntity.get(PositionComponent);
                
                let doorPositionX = doorPosition.x;
                let doorPositionY = doorPosition.y;
                if (side === 1) doorPositionX += doorCmp.offset;
                else doorPositionY += doorCmp.offset;
                
                const isDoorOpened = side === 1 ? doorPositionX >= mapX + 1 : doorPositionY >= mapY + 1;
                if (isDoorOpened) return;
                
                const isHitWall = side === 1 ? sideDistY - deltaDistY * (0.5 + this.doorWidth / 2) > sideDistX : sideDistX - deltaDistX * (0.5 + this.doorWidth / 2) > sideDistY;
                if (isHitWall) return;
                
                let hitDoorPart = null;
                let offset = side === 0 ? stepX * (0.5 - this.doorWidth / 2) : stepY * (0.5 - this.doorWidth / 2);
                
                const perpWallDistOnFrontFace = this.calculatePerpWallDist(side, mapX, mapY, playerPos, stepX, stepY, rayDirX, rayDirY, offset);
                let rayX = playerPos.x + rayDirX * perpWallDistOnFrontFace;
                let rayY = playerPos.y + rayDirY * perpWallDistOnFrontFace;
                
                const isHitDoor = side === 1 ? rayX > doorPositionX : rayY > doorPositionY;
                
                if (isHitDoor) {
                    hitDoorPart = "frontFace";
                }
                
                if (!hitDoorPart) {
                    const rayAngleRad = degreeToRadians(rayAngle);
                    if (side === 1) {
                        const closestDoorCornetPoint = { x: doorPositionX, y: mapY + 0.5 - this.doorWidth / 2 };
                        const angToClosestCorner = normalizeAngleInRad(Math.atan2(closestDoorCornetPoint.y - playerPos.y, closestDoorCornetPoint.x - playerPos.x));
                        const angleToFaresCorner = normalizeAngleInRad(Math.atan2(closestDoorCornetPoint.y + this.doorWidth - playerPos.y, closestDoorCornetPoint.x - playerPos.x));
                        if (rayAngleRad > angToClosestCorner && rayAngleRad < angleToFaresCorner) {
                            hitDoorPart = "sideFace";
                            const leg = doorPositionX - rayX;
                            const hypotenuse = leg / Math.cos(rayAngleRad < Math.PI ? rayAngleRad : rayAngleRad - Math.PI);
                            offset += Math.sqrt(hypotenuse ** 2 - leg ** 2) * stepY;
                        } else {
                            return;
                        }
                    } else {
                        const closestDoorCornetPoint = { x: mapX + 0.5 - this.doorWidth / 2, y: doorPositionY };
                        const angToClosestCorner = Math.atan2(closestDoorCornetPoint.y - playerPos.y, closestDoorCornetPoint.x - playerPos.x);
                        const angleToFaresCorner = Math.atan2(closestDoorCornetPoint.y - playerPos.y, closestDoorCornetPoint.x + this.doorWidth - playerPos.x);
                        if (rayAngleRad > angleToFaresCorner && rayAngleRad < angToClosestCorner) {
                            hitDoorPart = "sideFace";
                            const leg = doorPositionY - rayY;
                            const hypotenuse = leg / Math.sin(rayAngleRad);
                            offset += Math.sqrt(hypotenuse ** 2 - leg ** 2) * stepX;
                        } else {
                            return;
                        }
                    }
                }
                
                if (!hitDoorPart) return;
                
                const perpWallDist = this.calculatePerpWallDist(side, mapX, mapY, playerPos, stepX, stepY, rayDirX, rayDirY, offset);
                rayX = playerPos.x + rayDirX * perpWallDist;
                rayY = playerPos.y + rayDirY * perpWallDist;
                
                const textureOffset = doorCmp.isVertical ? { x: rayX - doorPositionX, y: Math.floor(rayY) - doorPositionY } : { x: Math.floor(rayX) - doorPositionX, y: rayY - doorPositionY };
                const texture = mapEntity.get(TextureComponent).texture;
                
                const texturePositionX = hitDoorPart === "frontFace" ? Math.floor((texture.width * (rayX + textureOffset.x + rayY + textureOffset.y)) % texture.width) : 0;
                const correctedDist = perpWallDist * fishEyeFixCoef;
                const wallHeight = Math.floor(screenHeight / 2 / correctedDist);
                
                return {
                    rayX,
                    rayY,
                    texturePositionX: texturePositionX,
                    texture: texture,
                    entityHeight: wallHeight,
                    distance: correctedDist,
                };
            }
            
            calculatePerpWallDist(side, mapX, mapY, startRayPos, stepX, stepY, rayDirX, rayDirY, offset = 0) {
                return side === 0 ? Math.abs((mapX - startRayPos.x + offset + (1 - stepX) / 2) / rayDirX) : Math.abs((mapY - startRayPos.y + offset + (1 - stepY) / 2) / rayDirY);
            }
        }
        
        class RenderSystem extends System {
            constructor(ecs, container, level, textureManager) {
                super(ecs);
                this.componentsRequired = new Set([PositionComponent]);
                this.mapEntityRenders = [];
                this.width = 640;
                this.height = 480;
                this.rayMaxDistanceRay = 20;
                this.player = { pos: { x: 0, y: 0 }, angle: 0 };
                this.level = level;
                this.container = container;
                this.textureManager = textureManager;
                
                this.canvas = new WebglCanvas({
                    id: "camera",
                    height: this.height,
                    width: this.width,
                });
                
                this.mapEntityRenders = [new DoorRender(), new WallRender()];
                this.lightSystem = this.ecs.getSystem(LightSystem);
            }
            
            start() {
                this.container.appendChild(this.canvas.element);
            }
            
            update() {
                this.canvas.clear();
                const [player] = this.ecs.query([PlayerComponent]);
                const playerContainer = this.ecs.getComponents(player);
                if (!playerContainer) return;
                
                const posCmp = playerContainer.get(PositionComponent);
                const angleCmp = playerContainer.get(AngleComponent);
                this.player = { pos: posCmp, angle: angleCmp.angle };
                
                this.canvas.createBufferSnapshot();
                this.render(playerContainer);
                this.canvas.commitBufferSnapshot();
            }
            
            destroy() {
                this.canvas.element.remove();
            }
            
            render(player) {
                const playerFov = player.get(CameraComponent);
                const textureMap = this.ecs.getSystem(MapTextureSystem).textureMap;
                const polarMap = this.ecs.getSystem(MapPolarSystem).polarMap;
                
                let rayAngle = normalizeAngle(this.player.angle - playerFov.fov / 2);
                
                for (let screenX = 0; screenX < this.width; screenX++) {
                    const rayRad = degreeToRadians(rayAngle);
                    const fishEyeFixCoef = Math.cos(degreeToRadians(rayAngle - this.player.angle));
                    
                    const rayDirX = Math.cos(rayRad);
                    const rayDirY = Math.sin(rayRad);
                    
                    let mapX = Math.floor(this.player.pos.x);
                    let mapY = Math.floor(this.player.pos.y);
                    
                    const deltaDistX = Math.abs(1 / rayDirX);
                    const deltaDistY = Math.abs(1 / rayDirY);
                    
                    let stepX, stepY, sideDistX, sideDistY;
                    
                    if (rayDirX < 0) {
                        stepX = -1;
                        sideDistX = (this.player.pos.x - mapX) * deltaDistX;
                    } else {
                        stepX = 1;
                        sideDistX = (mapX + 1.0 - this.player.pos.x) * deltaDistX;
                    }
                    
                    if (rayDirY < 0) {
                        stepY = -1;
                        sideDistY = (this.player.pos.y - mapY) * deltaDistY;
                    } else {
                        stepY = 1;
                        sideDistY = (mapY + 1.0 - this.player.pos.y) * deltaDistY;
                    }
                    
                    let side = 0;
                    let mapEntity = null;
                    let renderer = null;
                    let renderObjectInfo = null;
                    
                    while (!renderObjectInfo) {
                        if (sideDistX < sideDistY) {
                            sideDistX += deltaDistX;
                            mapX += stepX;
                            side = 0;
                        } else {
                            sideDistY += deltaDistY;
                            mapY += stepY;
                            side = 1;
                        }
                        
                        mapEntity = textureMap.get(mapX, mapY);
                        if (mapEntity) {
                            renderer = this.mapEntityRenders.find((render) => render.canRender(mapEntity));
                            renderObjectInfo = renderer?.render(mapEntity, this.height, rayAngle, side, sideDistX, sideDistY, deltaDistX, deltaDistY, mapX, mapY, this.player.pos, stepX, stepY, rayDirX, rayDirY, fishEyeFixCoef);
                        }
                    }
                    
                    if (mapEntity && renderer) {
                        this.drawTextureLine(screenX, renderObjectInfo);
                        this._drawFloorLine(screenX, renderObjectInfo.entityHeight, rayAngle);
                    } else {
                        this._drawFloorLine(screenX, 0, rayAngle);
                    }
                    
                    rayAngle += normalizeAngle(playerFov.fov / this.width);
                    const incrementAngle = playerFov.fov / this.width;
                    
                    const polarEntities = polarMap.select(renderObjectInfo?.distance ?? this.rayMaxDistanceRay, rayAngle, rayAngle + incrementAngle);
                    for (const polarEntity of polarEntities) {
                        this._drawSpriteLine(screenX, rayAngle, polarEntity);
                    }
                }
            }
            
            drawTextureLine(screenX, { entityHeight, texture, texturePositionX, rayX, rayY }) {
                const yIncrementer = (entityHeight * 2) / texture.height;
                let y = this.height / 2 - entityHeight;
                const lightLevel = this.lightSystem.getLightingLevelForPoint(rayX, rayY);
                
                for (let i = 0; i < texture.height; i++) {
                    if (y > -yIncrementer && y < this.height) {
                        this.canvas.drawVerticalLine({
                            x: screenX,
                            y1: y,
                            y2: Math.floor(y + yIncrementer),
                            color: applyBrightness(texture.colors[i][texturePositionX], lightLevel),
                        });
                    }
                    y += yIncrementer;
                }
            }
            
            _drawSpriteLine(screenX, rayAngle, polarEntity) {
                const container = polarEntity.container;
                const animateSprite = container.get(AnimatedSpriteComponent)?.sprite;
                const staticSprite = container.get(SpriteComponent)?.sprite;
                const highlight = container.get(HighlightComponent);
                const spritePosition = container.get(PositionComponent);
                const sprite = animateSprite || staticSprite;
                if (!sprite || !spritePosition) return;
                
                const { width: spriteWidth, height: spriteHeight, colors: spriteColors } = sprite;
                const projectionHeight = (this.height / (2 * polarEntity.distance)) | 0;
                const yIncrementer = (projectionHeight * 2) / spriteHeight;
                let y = (this.height / 2 - projectionHeight) | 0;
                
                const a1 = normalizeAngle(rayAngle - polarEntity.angleFrom);
                const a2 = normalizeAngle(polarEntity.angleTo - polarEntity.angleFrom);
                const xTexture = ((a1 / a2) * spriteWidth) | 0;
                
                const lightLevel = this.lightSystem.getLightingLevelForPoint(spritePosition.x, spritePosition.y);
                
                let highlightPercent = 0;
                if (highlight) {
                    const timeLeft = highlight.startedAt + highlight.duration - Date.now();
                    highlightPercent = Math.max(0, timeLeft / highlight.duration);
                }
                
                for (let i = 0; i < spriteHeight; i++) {
                    const spriteColor = spriteColors[i][xTexture];
                    const color = highlight ? overlayColor(spriteColor, highlight.color, highlightPercent) : spriteColor;
                    
                    if (y > -yIncrementer && y < this.height) {
                        this.canvas.drawVerticalLine({
                            x: screenX,
                            y1: y,
                            y2: (y + yIncrementer) | 0,
                            color: applyBrightness(color, lightLevel),
                        });
                    }
                    y += yIncrementer;
                }
            }
            
            _drawFloorLine(x, wallHeight, rayAngle) {
                const texture = this.textureManager.get("floor");
                const { width: textureWidth, height: textureHeight, colors } = texture;
                const halfHeight = this.height / 2;
                const start = halfHeight + wallHeight + 1;
                const rayAngleRad = degreeToRadians(rayAngle);
                const directionCos = Math.cos(rayAngleRad);
                const directionSin = Math.sin(rayAngleRad);
                const angleDiffCos = 1 / Math.cos(degreeToRadians(this.player.angle) - rayAngleRad);
                
                for (let y = start; y < this.height; y++) {
                    const yDiff = 2 * y - this.height;
                    const distance = (this.height / yDiff) * angleDiffCos;
                    const tileX = distance * directionCos + this.player.pos.x;
                    const tileY = distance * directionSin + this.player.pos.y;
                    const lightLevel = this.lightSystem.getLightingLevelForPoint(tileX, tileY);
                    const textureX = ((tileX * textureWidth) | 0) % textureWidth;
                    const textureY = ((tileY * textureHeight) | 0) % textureHeight;
                    const color = applyBrightness(colors[textureX][textureY], lightLevel);
                    this.canvas.drawPixel({ x, y, color });
                }
            }
        }
        
        class MinimapSystem extends System {
            constructor(ecs, container, level) {
                super(ecs);
                this.componentsRequired = new Set([MinimapComponent, PositionComponent]);
                this.scale = 20;
                this.container = container;
                
                const cols = level.map[0].length;
                const rows = level.map.length;
                
                let style = "z-index: 3;position: absolute;right: 20px;bottom: 10px;";
                this.canvas = new DefaultCanvas({
                    id: "minimap",
                    height: rows * this.scale,
                    width: cols * this.scale,
                    style,
                });
            }
            
            start() {
                this.container.appendChild(this.canvas.element);
            }
            
            update(_, entities) {
                this.canvas.clear();
                this.canvas.drawBackground("green");
                const renderSystem = this.ecs.getSystem(RenderSystem);
                
                for (const entity of entities) {
                    const components = this.ecs.getComponents(entity);
                    const { color } = components.get(MinimapComponent);
                    const renderer = renderSystem.mapEntityRenders.find((render) => render.canRender(components));
                    
                    if (renderer) {
                        const edges = renderer.getArmature(components);
                        this.drawPolygon(edges, color);
                        continue;
                    }
                    
                    const { x, y } = components.get(PositionComponent);
                    if (components.has(BoxComponent)) {
                        const { size } = components.get(BoxComponent);
                        this.drawSquare(x, y, size, color);
                    }
                    if (components.has(CircleComponent)) {
                        const { radius } = components.get(CircleComponent);
                        this.drawCircle(x, y, radius, color);
                    }
                }
            }
            
            destroy() {
                this.canvas.element.remove();
            }
            
            drawPolygon(paths, color) {
                this.canvas.drawPolygon({ paths: paths.map((point) => point * this.scale), color });
            }
            
            drawSquare(x, y, size, color) {
                this.canvas.drawRect({ x: x * this.scale, y: y * this.scale, width: size * this.scale, height: size * this.scale, color });
            }
            
            drawCircle(x, y, radius, color) {
                this.canvas.drawCircle({ x: x * this.scale, y: y * this.scale, radius: radius * this.scale, color });
            }
        }
        
        // ===== WEAPON SYSTEM =====
        const WEAPON_KNIFE_INDEX = 1;
        const WEAPON_PISTOL_INDEX = 2;
        const WEAPON_MACHINE_GUN_INDEX = 3;
        
        class WeaponSystem extends System {
            constructor(ecs, container, animationManager, textureManager, soundManager) {
                super(ecs);
                this.componentsRequired = new Set([BulletComponent]);
                this.width = 640;
                this.height = 480;
                this.container = container;
                this.soundManager = soundManager;
                this.textureManager = textureManager;
                this.animationManager = animationManager;
                this.weaponSprite = null;
                
                this.canvas = new DefaultCanvas({
                    id: "weapon",
                    height: this.height,
                    width: this.width,
                });
            }
            
            start() {
                this.container.appendChild(this.canvas.element);
                this.createListeners();
            }
            
            destroy() {
                this.canvas.element.remove();
                this.destroyListeners();
            }
            
            renderSprite() {
                if (this.weaponSprite) {
                    const texture = this.weaponSprite.sprite;
                    this.canvas.clear();
                    this.canvas.context.drawImage(
                        this.createImageFromTexture(texture),
                        this.width / 2 - texture.width / 2,
                        this.height - texture.height
                    );
                }
            }
            
            createImageFromTexture(texture) {
                const canvas = document.createElement('canvas');
                canvas.width = texture.width;
                canvas.height = texture.height;
                const ctx = canvas.getContext('2d');
                const imgData = ctx.createImageData(texture.width, texture.height);
                
                for (let y = 0; y < texture.height; y++) {
                    for (let x = 0; x < texture.width; x++) {
                        const color = texture.colors[y][x];
                        const i = (y * texture.width + x) * 4;
                        imgData.data[i] = color.r;
                        imgData.data[i + 1] = color.g;
                        imgData.data[i + 2] = color.b;
                        imgData.data[i + 3] = color.a;
                    }
                }
                ctx.putImageData(imgData, 0, 0);
                return canvas;
            }
            
            update(dt, bullets) {
                const [player] = this.ecs.query([PlayerComponent]);
                const entities = this.ecs.query([CircleComponent, HealthComponent]);
                const playerComponents = this.ecs.getComponents(player);
                const playerComponent = playerComponents.get(PlayerComponent);
                this.weaponSprite = playerComponent.currentWeapon?.sprite;
                
                if (this.weaponSprite) {
                    this.weaponSprite.update(dt);
                    this.renderSprite();
                }
                
                bullets.forEach((bullet) => {
                    const bulletContainer = this.ecs.getComponents(bullet);
                    const bulletCollision = bulletContainer.get(CollisionComponent);
                    
                    if (bulletCollision.isCollided) {
                        this.ecs.removeEntity(bullet);
                        return;
                    }
                    
                    const entity = this.findBulletCollision(bulletContainer, entities);
                    if (entity === undefined) return;
                    
                    const entityContainer = this.ecs.getComponents(entity);
                    if (!entityContainer) return;
                    
                    const entityHealth = entityContainer.get(HealthComponent);
                    if (!entityHealth) return;
                    
                    const entityAnimation = entityContainer.get(AnimatedSpriteComponent);
                    
                    if (entityHealth.current > 0) {
                        if (entity === player) this.soundManager.playSound("hurt");
                        
                        const color = { r: 255, g: 0, b: 0, a: 1 };
                        const entityHighlight = entityContainer.get(HighlightComponent);
                        
                        if (entityHighlight) {
                            entityHighlight.color = color;
                            entityHighlight.startedAt = Date.now();
                        } else {
                            this.ecs.addComponent(entity, new HighlightComponent(color));
                        }
                        
                        entityHealth.current -= bulletContainer.get(BulletComponent).damage;
                    }
                    
                    if (entityHealth.current <= 0) {
                        this.ecs.removeComponent(entity, MoveComponent);
                        this.ecs.removeComponent(entity, HealthComponent);
                        this.ecs.removeComponent(entity, AIComponent);
                        if (entityAnimation) entityAnimation.switchState("death", false);
                    }
                    
                    this.ecs.removeEntity(bullet);
                });
            }
            
            findBulletCollision(bullet, entities) {
                const bulletCircle = bullet.get(CircleComponent);
                const bulletPosition = bullet.get(PositionComponent);
                const bulletComponent = bullet.get(BulletComponent);
                const entityFromComponentContainer = this.ecs.getComponents(bulletComponent.fromEntity);
                const entityFromHasEnemy = entityFromComponentContainer.has(EnemyComponent);
                
                for (const entity of entities) {
                    if (bulletComponent.fromEntity === entity) continue;
                    const container = this.ecs.getComponents(entity);
                    const entityCircle = container.get(CircleComponent);
                    const entityPosition = container.get(PositionComponent);
                    const hasEnemy = container.has(EnemyComponent);
                    
                    if (hasEnemy && entityFromHasEnemy) continue;
                    
                    const d = distance(bulletPosition.x, bulletPosition.y, entityPosition.x, entityPosition.y);
                    if (d <= bulletCircle.radius + entityCircle.radius) return entity;
                }
            }
            
            handleDocumentClick = () => {
                const [player] = this.ecs.query([PlayerComponent, AngleComponent, PositionComponent]);
                const playerContainer = this.ecs.getComponents(player);
                const playerComponent = playerContainer.get(PlayerComponent);
                
                if (!playerComponent.currentWeapon) return;
                
                if (playerComponent.currentWeapon instanceof WeaponRangeComponent) {
                    this.attackWithRange(player);
                    return;
                }
                
                if (playerComponent.currentWeapon instanceof WeaponMeleeComponent) {
                    this.attackClose(player);
                }
            };
            
            attackClose(player) {
                const playerComponents = this.ecs.getComponents(player);
                const playerComponent = playerComponents.get(PlayerComponent);
                const playerPositionComponent = playerComponents.get(PositionComponent);
                const playerCircleComponent = playerComponents.get(CircleComponent);
                const playerWeaponComponent = playerComponent.currentWeapon;
                
                this.soundManager.playSound("attack-knife");
                this.weaponSprite?.switchState("attack", false);
                
                const enemies = this.ecs.query([EnemyComponent, PositionComponent, HealthComponent]);
                
                for (const enemy of enemies) {
                    const enemyComponents = this.ecs.getComponents(enemy);
                    const enemyAnimationComponent = enemyComponents.get(AnimatedSpriteComponent);
                    const enemyHealthComponent = enemyComponents.get(HealthComponent);
                    const enemyPositionComponent = enemyComponents.get(PositionComponent);
                    const enemyCircleComponent = enemyComponents.get(CircleComponent);
                    const enemyHighlightComponent = enemyComponents.get(HighlightComponent);
                    
                    const d = distance(enemyPositionComponent.x, enemyPositionComponent.y, playerPositionComponent.x, playerPositionComponent.y);
                    const isCollided = d < enemyCircleComponent.radius + playerCircleComponent.radius;
                    const shouldPlayerAttack = isCollided && enemyHealthComponent.current > 0;
                    
                    if (shouldPlayerAttack) {
                        enemyHealthComponent.current = Math.max(0, enemyHealthComponent.current - playerWeaponComponent.attackDamage);
                        const color = { r: 255, g: 0, b: 0, a: 1 };
                        
                        if (enemyHighlightComponent) {
                            enemyHighlightComponent.color = color;
                            enemyHighlightComponent.startedAt = Date.now();
                        } else {
                            this.ecs.addComponent(enemy, new HighlightComponent(color));
                        }
                        
                        if (enemyHealthComponent.current <= 0 && enemyAnimationComponent) {
                            enemyAnimationComponent.switchState("death", false);
                        }
                    }
                }
            }
            
            attackWithRange(player) {
                const playerComponents = this.ecs.getComponents(player);
                const playerComponent = playerComponents.get(PlayerComponent);
                const weaponRangeComponent = playerComponent.currentWeapon;
                
                if (weaponRangeComponent.bulletTotal <= 0) return;
                
                weaponRangeComponent.bulletTotal -= 1;
                this.soundManager.playSound("gun-shot");
                this.weaponSprite?.switchState("attack", false);
                
                const entity = this.ecs.addEntity();
                const sprite = this.textureManager.get(weaponRangeComponent.bulletSprite);
                
                this.ecs.addComponent(entity, new CollisionComponent());
                if (sprite) this.ecs.addComponent(entity, new SpriteComponent(sprite));
                
                this.ecs.addComponent(entity, new BulletComponent(player, weaponRangeComponent.bulletDamage));
                this.ecs.addComponent(entity, new PositionComponent(playerComponents.get(PositionComponent).x, playerComponents.get(PositionComponent).y));
                this.ecs.addComponent(entity, new AngleComponent(playerComponents.get(AngleComponent).angle));
                this.ecs.addComponent(entity, new CircleComponent(0.25));
                this.ecs.addComponent(entity, new MinimapComponent("yellow"));
                this.ecs.addComponent(entity, new MoveComponent(weaponRangeComponent.bulletSpeed, false, MainDirection.Forward));
            }
            
            createListeners() {
                document.addEventListener("pointerdown", this.handleDocumentClick);
            }
            
            destroyListeners() {
                document.removeEventListener("pointerdown", this.handleDocumentClick);
            }
        }
        
        class MapItemSystem extends System {
            constructor(ecs, animationManager, soundManager) {
                super(ecs);
                this.componentsRequired = new Set([PositionComponent, ItemComponent]);
                this.animationManager = animationManager;
                this.soundManager = soundManager;
            }
            
            start() {}
            
            update(_, entities) {
                const [player] = this.ecs.query([PlayerComponent, PositionComponent]);
                const playerContainer = this.ecs.getComponents(player);
                if (!playerContainer) return;
                
                const playerPlayer = playerContainer.get(PlayerComponent);
                const playerPosition = playerContainer.get(PositionComponent);
                const playerHealth = playerContainer.get(HealthComponent);
                const playerWeapon = playerContainer.get(WeaponRangeComponent);
                
                entities.forEach((entity) => {
                    const entityItem = this.ecs.getComponents(entity).get(ItemComponent);
                    const entityPosition = this.ecs.getComponents(entity).get(PositionComponent);
                    
                    if (Math.floor(playerPosition.x) === Math.floor(entityPosition.x) && Math.floor(playerPosition.y) === Math.floor(entityPosition.y)) {
                        if (!playerWeapon && entityItem.type === "pistol_weapon") {
                            const pistolWeapon = this.generatePistolWeapon(this.animationManager);
                            this.soundManager.playSound("pick");
                            playerPlayer.currentWeapon = pistolWeapon;
                            
                            if (!playerPlayer.weapons[WEAPON_PISTOL_INDEX]) {
                                playerPlayer.weapons[WEAPON_PISTOL_INDEX] = pistolWeapon;
                            } else {
                                playerPlayer.weapons[WEAPON_PISTOL_INDEX].bulletTotal += 30;
                            }
                            
                            this.ecs.removeEntity(entity);
                        }
                        
                        if (playerPlayer.weapons[WEAPON_PISTOL_INDEX] && entityItem.type === "pistol_ammo") {
                            this.soundManager.playSound("pick");
                            playerPlayer.weapons[WEAPON_PISTOL_INDEX].bulletTotal += entityItem.value;
                            this.ecs.removeEntity(entity);
                        }
                        
                        if (playerHealth && entityItem.type === "health_pack") {
                            playerHealth.current += entityItem.value;
                            this.ecs.removeEntity(entity);
                        }
                    }
                });
            }
            
            generatePistolWeapon(animationManager) {
                return new WeaponRangeComponent({
                    bulletTotal: 30,
                    bulletSprite: "pistol_bullet",
                    bulletDamage: 100,
                    bulletSpeed: 35,
                    attackDistance: 15,
                    attackFrequency: 500,
                    sprite: new AnimatedSpriteComponent("idle", {
                        attack: animationManager.get("pistolAttack"),
                        idle: animationManager.get("pistolIdle"),
                    }),
                });
            }
            
            destroy() {}
        }
        
        class AISystem extends System {
            constructor(ecs, textureManager, soundManager) {
                super(ecs);
                this.componentsRequired = new Set([AIComponent, EnemyComponent, PositionComponent, AngleComponent, MoveComponent]);
                this.soundManager = soundManager;
                this.textureManager = textureManager;
            }
            
            start() {}
            
            update(dt, enemies) {
                const [player] = this.ecs.query([PlayerComponent, HealthComponent, CircleComponent]);
                if (player === undefined) return;
                
                const playerContainer = this.ecs.getComponents(player);
                const playerPosition = playerContainer.get(PositionComponent);
                const playerCircle = playerContainer.get(CircleComponent);
                
                for (const enemy of enemies) {
                    const components = this.ecs.getComponents(enemy);
                    const enemyAI = components.get(AIComponent);
                    const enemyHealth = components.get(HealthComponent);
                    const enemyPosition = components.get(PositionComponent);
                    const enemyAngle = components.get(AngleComponent);
                    const enemyCircle = components.get(CircleComponent);
                    const enemyMove = components.get(MoveComponent);
                    const enemyAnimation = components.get(AnimatedSpriteComponent);
                    
                    if (enemyHealth.current <= 0) continue;
                    
                    const dx = playerPosition.x - enemyPosition.x;
                    const dy = playerPosition.y - enemyPosition.y;
                    const d = Math.sqrt(dx ** 2 + dy ** 2) - playerCircle.radius - enemyCircle?.radius;
                    
                    const shouldEnemyBeActivated = enemyAI.activateDistance > d && !this.hasTextureBetween(playerPosition, enemyPosition);
                    
                    if (!shouldEnemyBeActivated) {
                        enemyAnimation.switchState("idle", true);
                        enemyMove.mainDirection = MainDirection.None;
                        enemyMove.sideDirection = SideDirection.None;
                        continue;
                    }
                    
                    const angle = dx <= 0 ? radiansToDegrees(Math.atan(dy / dx)) + 180 : radiansToDegrees(Math.atan(dy / dx));
                    enemyAngle.angle = normalizeAngle(angle);
                    
                    if (components.has(WeaponRangeComponent)) {
                        this.attackWithRange(dt, d, player, enemy);
                        continue;
                    }
                    
                    if (components.has(WeaponMeleeComponent)) {
                        this.attackClose(dt, d, player, enemy);
                    }
                }
            }
            
            hasTextureBetween(playerPosition, enemyPosition) {
                const textureMap = this.ecs.getSystem(MapTextureSystem).textureMap;
                let startX = playerPosition.x;
                let startY = playerPosition.y;
                const endX = enemyPosition.x;
                const endY = enemyPosition.y;
                const dx = startX < endX ? 0.1 : -0.1;
                const dy = startY < endY ? 0.1 : -0.1;
                
                while (startX < endX || startY < endY) {
                    const textureContainer = textureMap.get(Math.floor(startX), Math.floor(startY));
                    if (textureContainer) {
                        const doorComponent = textureContainer.get(DoorComponent);
                        if (doorComponent) return !doorComponent.isOpened;
                        return true;
                    }
                    if (startX < endX) startX += dx;
                    if (startY < endY) startY += dy;
                }
                return false;
            }
            
            attackClose(dt, d, player, enemy) {
                const playerComponents = this.ecs.getComponents(player);
                const playerHealth = playerComponents.get(HealthComponent);
                const enemyComponents = this.ecs.getComponents(enemy);
                const enemyAI = enemyComponents.get(AIComponent);
                const enemyAnimation = enemyComponents.get(AnimatedSpriteComponent);
                const enemyWeapon = enemyComponents.get(WeaponMeleeComponent);
                const enemyMove = enemyComponents.get(MoveComponent);
                
                const shouldEnemyBeMoved = d > 0;
                const shouldEnemyAttack = d <= 0;
                const shouldEnemyDamage = enemyAI.actionPassedTime >= enemyWeapon.attackFrequency / 1000;
                
                if (shouldEnemyBeMoved) {
                    enemyAnimation.switchState("walk", true);
                    enemyMove.mainDirection = MainDirection.Forward;
                    return;
                } else {
                    enemyMove.mainDirection = MainDirection.None;
                    enemyMove.sideDirection = SideDirection.None;
                }
                
                if (shouldEnemyAttack) {
                    enemyAnimation.switchState("attack", true);
                    enemyAI.actionPassedTime += dt;
                } else {
                    enemyAI.actionPassedTime = 0;
                }
                
                if (shouldEnemyDamage) {
                    enemyAI.actionPassedTime = 0;
                    playerHealth.current = Math.max(0, playerHealth.current - enemyWeapon.attackDamage);
                }
            }
            
            attackWithRange(dt, d, _, enemy) {
                const components = this.ecs.getComponents(enemy);
                const enemyAI = components.get(AIComponent);
                const enemyAngle = components.get(AngleComponent);
                const enemyWeapon = components.get(WeaponRangeComponent);
                const enemyAnimation = components.get(AnimatedSpriteComponent);
                const enemyPosition = components.get(PositionComponent);
                const enemyCircle = components.get(CircleComponent);
                const enemyMove = components.get(MoveComponent);
                
                const shouldEnemyBeMoved = enemyWeapon.attackDistance < d && d > 0;
                
                if (shouldEnemyBeMoved) {
                    enemyAnimation.switchState("walk", true);
                    enemyMove.mainDirection = MainDirection.Forward;
                    return;
                } else {
                    enemyMove.mainDirection = MainDirection.None;
                    enemyMove.sideDirection = SideDirection.None;
                }
                
                const shouldEnemyAttack = enemyWeapon.attackDistance >= d;
                const shouldEnemyDamage = enemyAI.actionPassedTime >= enemyWeapon.attackFrequency / 1000;
                
                if (shouldEnemyAttack) {
                    enemyAnimation.switchState("attack", true);
                    enemyAI.actionPassedTime += dt;
                } else {
                    enemyAI.actionPassedTime = 0;
                }
                
                if (shouldEnemyDamage) {
                    enemyAI.actionPassedTime = 0;
                    const entity = this.ecs.addEntity();
                    const sprite = this.textureManager.get(enemyWeapon.bulletSprite);
                    const radius = enemyWeapon.attackDistance === 0 ? enemyCircle.radius : 0.25;
                    
                    this.ecs.addComponent(entity, new CollisionComponent());
                    if (sprite) this.ecs.addComponent(entity, new SpriteComponent(sprite));
                    
                    this.ecs.addComponent(entity, new BulletComponent(enemy, enemyWeapon.bulletDamage));
                    this.ecs.addComponent(entity, new PositionComponent(enemyPosition.x, enemyPosition.y));
                    this.ecs.addComponent(entity, new AngleComponent(enemyAngle.angle));
                    this.ecs.addComponent(entity, new CircleComponent(radius));
                    this.ecs.addComponent(entity, new MinimapComponent("yellow"));
                    this.ecs.addComponent(entity, new MoveComponent(enemyWeapon.bulletSpeed, false, MainDirection.Forward));
                    
                    if (enemyWeapon.attackDistance === 0) {
                        this.ecs.removeEntity(entity);
                    }
                }
            }
            
            destroy() {}
        }
        
        // ===== MANAGERS =====
        class SoundManager {
            constructor() {
                this.sounds = {};
                this.currentBackgroundId = '';
                this.isMuted = false;
            }
            
            async load(presets) {
                await Promise.all(presets.map(preset => new Promise((resolve) => {
                    const audio = new Audio(preset.url);
                    audio.crossOrigin = "anonymous";
                    audio.onload = () => resolve();
                    audio.onabort = () => resolve();
                    audio.onerror = () => resolve();
                    audio.load();
                    resolve();
                    this.sounds[preset.id] = audio;
                })));
            }
            
            checkMuted() {
                return this.isMuted;
            }
            
            mute() {
                this.isMuted = true;
                this.pauseBackground();
            }
            
            unmute() {
                this.isMuted = false;
                this.resumeBackground();
            }
            
            playSound(id, volume = 1) {
                const audio = this.sounds[id];
                if (!audio) return;
                const copy = audio.cloneNode();
                copy.volume = volume;
                copy.play().catch(() => {});
            }
            
            playBackground(id) {
                this.currentBackgroundId = id;
                const audio = this.sounds[id];
                if (audio) {
                    audio.loop = true;
                    audio.play().catch(() => {});
                }
            }
            
            resumeBackground() {
                if (this.sounds[this.currentBackgroundId]) {
                    this.sounds[this.currentBackgroundId].play().catch(() => {});
                }
            }
            
            pauseBackground() {
                if (this.sounds[this.currentBackgroundId]) {
                    this.sounds[this.currentBackgroundId].pause();
                }
            }
        }
        
        class TextureManager {
            constructor() {
                this.textures = {};
            }
            
            async load(presets) {
                for (const preset of presets) {
                    try {
                        this.textures[preset.id] = await extractTextureBitmap(preset.url);
                    } catch (e) {
                        console.warn(`Failed to load texture: ${preset.url}`);
                        // Create placeholder texture
                        this.textures[preset.id] = this.createPlaceholderTexture(64, 64);
                    }
                }
            }
            
            createPlaceholderTexture(width, height) {
                const colors = [];
                for (let y = 0; y < height; y++) {
                    const row = [];
                    for (let x = 0; x < width; x++) {
                        const isChecker = (Math.floor(x / 8) + Math.floor(y / 8)) % 2 === 0;
                        row.push(isChecker ? { r: 128, g: 128, b: 128, a: 255 } : { r: 64, g: 64, b: 64, a: 255 });
                    }
                    colors.push(row);
                }
                return { width, height, colors };
            }
            
            get(id) {
                return this.textures[id];
            }
        }
        
        class AnimationManager {
            constructor() {
                this.animations = {};
            }
            
            async load(presets) {
                for (const preset of presets) {
                    try {
                        this.animations[preset.id] = await Promise.all(preset.frames.map(async url => await extractTextureBitmap(url)));
                    } catch (e) {
                        console.warn(`Failed to load animation: ${preset.id}`);
                        this.animations[preset.id] = [this.createPlaceholderTexture(64, 64)];
                    }
                }
            }
            
            createPlaceholderTexture(width, height) {
                const colors = [];
                for (let y = 0; y < height; y++) {
                    const row = [];
                    for (let x = 0; x < width; x++) {
                        row.push({ r: 255, g: 0, b: 255, a: 255 });
                    }
                    colors.push(row);
                }
                return { width, height, colors };
            }
            
            get(id) {
                return this.animations[id];
            }
        }
        
        // ===== VIEWS =====
        class ContentView {
            constructor(title, subtitle = []) {
                this.title = title;
                this.subtitle = subtitle;
                this.width = 640;
                this.height = 480;
                this.canvas = new DefaultCanvas({
                    id: "content",
                    height: this.height,
                    width: this.width,
                    style: "border: 1px solid black",
                });
            }
            
            renderText(y, fontSize, text) {
                this.canvas.drawText({
                    x: this.width / 2,
                    y,
                    align: 'center',
                    text,
                    color: 'white',
                    font: `${fontSize}px Lucida Console`
                });
            }
            
            render() {
                this.canvas.clear();
                this.canvas.drawBackground('black');
                const lineHeight = 40;
                
                if (this.subtitle?.length) {
                    let y = this.height / 2 - lineHeight * this.subtitle.length / 2;
                    this.renderText(y, 60, this.title);
                    y += lineHeight;
                    this.subtitle?.forEach((line) => {
                        y += lineHeight;
                        this.renderText(y, 30, line);
                    });
                } else {
                    this.renderText(this.height / 2, 40, this.title);
                }
            }
        }
        
        class LevelPlayerView {
            constructor(container) {
                this.width = 640;
                this.height = 480;
                this.container = container;
                this.canvas = new DefaultCanvas({
                    id: "ui",
                    height: this.height,
                    width: this.width,
                });
                this.container.appendChild(this.canvas.element);
                this.icons = ["health", "bullets", "timer"];
                this.iconsImages = {};
                this.loadIcons();
            }
            
            loadIcons() {
                for (const icon of this.icons) {
                    const img = new Image();
                    img.crossOrigin = "anonymous";
                    img.src = `https://ufocoder.github.io/fps/assets/icons/${icon}.png`;
                    this.iconsImages[icon] = img;
                }
            }
            
            render(state) {
                this.canvas.clear();
                this.canvas.drawText({
                    x: this.width - 10,
                    y: 30,
                    text: state.soundMuted ? "Music off" : "Music on",
                    color: "grey",
                    align: "right",
                    font: "18px serif",
                });
                
                if (state.health) this.drawHealth(state.health, { x: 10, y: 10 });
                if (state.ammo) this.drawAmmo(state.ammo, { x: 10, y: 40 });
                if (state.timeLeft !== undefined) this.drawTimer(state.timeLeft, { x: this.canvas.width / 2 - 50, y: 10 });
            }
            
            drawHealth(healthValue, position) {
                const pulseSpeed = lerp(15, 2, minmax(healthValue / 100, 0, 1));
                const angle = (Date.now() / 1500) * pulseSpeed;
                const scale = 0.6 + 0.4 * (0.1 * Math.cos(angle) - 0.3 * Math.cos(4 * angle) + Math.abs(Math.cos(angle)));
                
                this.drawIcon("health", { x: position.x, y: position.y, width: 24, height: 24, scale });
                this.canvas.drawText({
                    x: position.x + 30,
                    y: position.y + 20,
                    text: healthValue.toString(),
                    align: "left",
                    color: "red",
                    font: "24px serif",
                });
            }
            
            drawAmmo(bulletTotal, position) {
                this.drawIcon("bullets", { x: position.x, y: position.y, width: 24, height: 24 });
                this.canvas.drawText({
                    x: position.x + 30,
                    y: position.y + 20,
                    text: bulletTotal.toString(),
                    align: "left",
                    color: "white",
                    font: "24px serif",
                });
            }
            
            drawTimer(time, position) {
                this.drawIcon("timer", { x: position.x, y: position.y, width: 24, height: 24 });
                this.canvas.drawText({
                    x: position.x + 30,
                    y: position.y + 20,
                    text: time.toFixed(2),
                    align: "left",
                    color: "white",
                    font: "24px serif",
                });
            }
            
            drawIcon(iconName, config) {
                const scale = config.scale ?? 1;
                if (this.iconsImages[iconName].complete) {
                    this.canvas.context.drawImage(
                        this.iconsImages[iconName],
                        config.x + (config.width / 2) * (1 - scale),
                        config.y + (config.height / 2) * (1 - scale),
                        config.width * scale,
                        config.height * scale,
                    );
                }
            }
            
            destroy() {
                this.canvas.element.remove();
            }
        }
        
        // ===== SCENES =====
        class TitleScene {
            constructor(container, playerState, title, subtitle) {
                this.container = container;
                this.playerState = playerState;
                this.view = new ContentView(title, subtitle);
                this.createListeners();
            }
            
            onComplete(cb) {
                this.onCompleteCallback = cb;
            }
            
            start() {
                this.container.appendChild(this.view.canvas.element);
                this.view.render();
            }
            
            destroy() {
                this.destroyListeners();
                this.view.canvas.element.remove();
            }
            
            createListeners() {
                document.addEventListener('keydown', this.handleDocumentKeydown);
                document.addEventListener('pointerdown', this.handleDocumentClick);
            }
            
            destroyListeners() {
                document.removeEventListener('keydown', this.handleDocumentKeydown);
                document.removeEventListener('pointerdown', this.handleDocumentClick);
            }
            
            handleDocumentKeydown = () => {
                if (this.onCompleteCallback) {
                    window.requestAnimationFrame(this.onCompleteCallback);
                }
            };
            
            handleDocumentClick = () => {
                if (this.onCompleteCallback) {
                    window.requestAnimationFrame(this.onCompleteCallback);
                }
            };
        }
        
        function createLoop(cb) {
            let isRunning = false;
            let previousTime;
            
            function play() {
                previousTime = performance.now();
                isRunning = true;
                
                function loop() {
                    if (!isRunning) return;
                    const currentTime = performance.now();
                    const dt = (currentTime - previousTime) / 1000;
                    cb(dt);
                    previousTime = currentTime;
                    requestAnimationFrame(loop);
                }
                requestAnimationFrame(loop);
            }
            
            function pause() {
                isRunning = false;
            }
            
            function checkRunning() {
                return isRunning;
            }
            
            return { play, pause, checkRunning };
        }
        
        class LevelScene {
            constructor({ container, level, soundManager, textureManager, animationManager, playerState }) {
                this.level = level;
                this.playerState = playerState;
                this.timeLeft = level.endingScenario.name === "survive" ? level.endingScenario?.timer : undefined;
                this.soundManager = soundManager;
                this.levelPlayerView = new LevelPlayerView(container);
                
                const ecs = new ECS();
                
                this.createLevelEntities(ecs, level, playerState, textureManager, animationManager);
                
                ecs.addSystem(new MapTextureSystem(ecs, level));
                ecs.addSystem(new MapPolarSystem(ecs));
                ecs.addSystem(new MapItemSystem(ecs, animationManager, soundManager));
                ecs.addSystem(new ControlSystem(ecs, container));
                ecs.addSystem(new MoveSystem(ecs));
                ecs.addSystem(new AnimationSystem(ecs));
                ecs.addSystem(new AISystem(ecs, textureManager, soundManager));
                ecs.addSystem(new WeaponSystem(ecs, container, animationManager, textureManager, soundManager));
                ecs.addSystem(new RotateSystem(ecs));
                ecs.addSystem(new DoorsSystem(ecs));
                ecs.addSystem(new LightSystem(ecs));
                ecs.addSystem(new RenderSystem(ecs, container, level, textureManager));
                ecs.addSystem(new MinimapSystem(ecs, container, level));
                
                this.ecs = ecs;
                this.loop = createLoop(this.onTick);
            }
            
            createLevelEntities(ecs, level, playerState, textureManager, animationManager) {
                const player = ecs.addEntity();
                const playerHealth = playerState.health || level.player.health;
                const playerComponent = new PlayerComponent();
                
                const knifeWeapon = new WeaponMeleeComponent({
                    sprite: new AnimatedSpriteComponent('idle', {
                        attack: animationManager.get("knifeAttack"),
                        idle: animationManager.get("knifeIdle"),
                    }),
                    attackDamage: 30,
                    attackFrequency: 500,
                });
                
                playerComponent.currentWeapon = knifeWeapon;
                playerComponent.weapons[WEAPON_KNIFE_INDEX] = knifeWeapon;
                
                if (playerState.ammo) {
                    const pistolWeapon = new WeaponRangeComponent({
                        bulletTotal: playerState.ammo,
                        bulletSprite: "pistol_bullet",
                        bulletDamage: 100,
                        bulletSpeed: 35,
                        attackDistance: 15,
                        attackFrequency: 500,
                        sprite: new AnimatedSpriteComponent("idle", {
                            attack: animationManager.get("pistolAttack"),
                            idle: animationManager.get("pistolIdle"),
                        }),
                    });
                    playerComponent.currentWeapon = pistolWeapon;
                    playerComponent.weapons[WEAPON_PISTOL_INDEX] = pistolWeapon;
                }
                
                ecs.addComponent(player, playerComponent);
                ecs.addComponent(player, new LightComponent(5, 0.5));
                ecs.addComponent(player, new ControlComponent());
                ecs.addComponent(player, new CircleComponent(0.4));
                ecs.addComponent(player, new PositionComponent(level.player.x, level.player.y));
                ecs.addComponent(player, new HealthComponent(playerHealth, playerHealth));
                ecs.addComponent(player, new AngleComponent(level.player.angle));
                ecs.addComponent(player, new MoveComponent(3, true));
                ecs.addComponent(player, new CollisionComponent());
                ecs.addComponent(player, new RotateComponent(360 / 30));
                ecs.addComponent(player, new CameraComponent(60));
                ecs.addComponent(player, new MinimapComponent("black"));
                
                // Items
                level.items?.forEach((item) => {
                    const entity = ecs.addEntity();
                    ecs.addComponent(entity, new PositionComponent(item.x, item.y));
                    ecs.addComponent(entity, new CircleComponent(item.radius));
                    ecs.addComponent(entity, new MinimapComponent("orange"));
                    ecs.addComponent(entity, new SpriteComponent(textureManager.get(item.type)));
                    ecs.addComponent(entity, new ItemComponent(item.type, item.value));
                });
                
                // Enemies
                level.enemies?.forEach((enemy) => {
                    const entity = ecs.addEntity();
                    ecs.addComponent(entity, new MoveComponent(1, true));
                    ecs.addComponent(entity, new CollisionComponent());
                    ecs.addComponent(entity, new EnemyComponent());
                    ecs.addComponent(entity, new CircleComponent(enemy.radius));
                    ecs.addComponent(entity, new PositionComponent(enemy.x, enemy.y));
                    ecs.addComponent(entity, new HealthComponent(enemy.health, enemy.health));
                    ecs.addComponent(entity, new AngleComponent(enemy.angle));
                    ecs.addComponent(entity, new RotateComponent());
                    ecs.addComponent(entity, new MinimapComponent("red"));
                    
                    if (enemy.aiDistance) {
                        ecs.addComponent(entity, new AIComponent(enemy.aiDistance));
                    }
                    
                    if (enemy.rangeWeapon) {
                        ecs.addComponent(entity, new WeaponRangeComponent({
                            bulletSprite: enemy.rangeWeapon.bulletSprite,
                            bulletTotal: Infinity,
                            bulletDamage: enemy.rangeWeapon.bulletDamage,
                            bulletSpeed: enemy.rangeWeapon.bulletSpeed,
                            attackDistance: enemy.rangeWeapon.attackDistance,
                            attackFrequency: enemy.rangeWeapon.attackFrequency,
                        }));
                    }
                    
                    if (enemy.meleeWeapon) {
                        ecs.addComponent(entity, new WeaponMeleeComponent({
                            attackDamage: enemy.meleeWeapon.damage,
                            attackFrequency: enemy.meleeWeapon.frequency,
                        }));
                    }
                    
                    const animStates = {
                        zombie: {
                            attack: animationManager.get("zombieAttack"),
                            idle: animationManager.get("zombieIdle"),
                            damage: animationManager.get("zombieDamage"),
                            death: animationManager.get("zombieDeath"),
                            walk: animationManager.get("zombieWalk"),
                        },
                        soldier: {
                            attack: animationManager.get("soldierAttack"),
                            idle: animationManager.get("soldierIdle"),
                            damage: animationManager.get("soldierDamage"),
                            death: animationManager.get("soldierDeath"),
                            walk: animationManager.get("soldierWalk"),
                        },
                        flyguy: {
                            attack: animationManager.get("flyguyAttack"),
                            idle: animationManager.get("flyguyIdle"),
                            damage: animationManager.get("flyguyDamage"),
                            death: animationManager.get("flyguyDeath"),
                            walk: animationManager.get("flyguyWalk"),
                        },
                        commando: {
                            attack: animationManager.get("commandoAttack"),
                            idle: animationManager.get("commandoIdle"),
                            damage: animationManager.get("commandoDamage"),
                            death: animationManager.get("commandoDeath"),
                            walk: animationManager.get("commandoWalk"),
                        },
                        tank: {
                            attack: animationManager.get("tankAttack"),
                            idle: animationManager.get("tankIdle"),
                            damage: animationManager.get("tankDamage"),
                            death: animationManager.get("tankDeath"),
                            walk: animationManager.get("tankWalk"),
                        },
                    };
                    
                    if (animStates[enemy.type]) {
                        ecs.addComponent(entity, new AnimatedSpriteComponent("idle", animStates[enemy.type]));
                    }
                });
                
                // Exit
                if (level.endingScenario.name === "exit") {
                    const exit = ecs.addEntity();
                    ecs.addComponent(exit, new BoxComponent(1));
                    ecs.addComponent(exit, new PositionComponent(level.endingScenario.position.x, level.endingScenario.position.y));
                    ecs.addComponent(exit, new MinimapComponent("yellow"));
                }
                
                // Walls
                level.map.forEach((row, y) => {
                    row.forEach((col, x) => {
                        const mapItem = level.mapEntities[col];
                        if (mapItem.type === "empty") return;
                        
                        if (mapItem.type === "light") {
                            const light = ecs.addEntity();
                            ecs.addComponent(light, new LightComponent(4, 1));
                            ecs.addComponent(light, new PositionComponent(x + 0.5, y + 0.5));
                            ecs.addComponent(light, new MinimapComponent("white"));
                            ecs.addComponent(light, new CircleComponent(0.1));
                            return;
                        }
                        
                        const mapItemEntity = ecs.addEntity();
                        const texture = textureManager.get(mapItem.texture);
                        
                        ecs.addComponent(mapItemEntity, new BoxComponent(1));
                        ecs.addComponent(mapItemEntity, new PositionComponent(x, y));
                        ecs.addComponent(mapItemEntity, new TextureComponent(texture));
                        
                        if (mapItem.type === "wall") {
                            ecs.addComponent(mapItemEntity, new MinimapComponent("grey"));
                        } else if (mapItem.type === "door") {
                            const aboveBloc = level.map[y - 1]?.[x];
                            const underBloc = level.map[y + 1]?.[x];
                            const isVerticalDoor = level.mapEntities[aboveBloc]?.type === "wall" && level.mapEntities[underBloc]?.type === "wall";
                            ecs.addComponent(mapItemEntity, new DoorComponent(false, isVerticalDoor));
                            ecs.addComponent(mapItemEntity, new MinimapComponent("blue"));
                        }
                    });
                });
            }
            
            getPlayerContainer() {
                const [player] = this.ecs.query([PlayerComponent, HealthComponent]);
                if (player === undefined) return;
                return this.ecs.getComponents(player);
            }
            
            shouldLevelBeCompleted() {
                const playerContainer = this.getPlayerContainer();
                if (!playerContainer) return false;
                
                const { endingScenario } = this.level;
                const enemies = this.ecs.query([EnemyComponent, HealthComponent]);
                
                switch (endingScenario.name) {
                    case "exit":
                        return (Math.floor(playerContainer.get(PositionComponent).x) === endingScenario.position.x && Math.floor(playerContainer.get(PositionComponent).y) === endingScenario.position.y);
                    case "enemy":
                        for (const enemy of enemies) {
                            if (this.ecs.getComponents(enemy).get(HealthComponent).current > 0) return false;
                        }
                        return true;
                    case "survive":
                        if (this.timeLeft !== undefined) return this.timeLeft <= 0;
                        return false;
                }
            }
            
            shouldLevelBeFailed() {
                const playerContainer = this.getPlayerContainer();
                if (!playerContainer) return true;
                return playerContainer.get(HealthComponent).current <= 0;
            }
            
            onTick = (dt) => {
                this.ecs.update(dt);
                this.updatePlayerView(dt);
                
                if (this.onCompleteCallback && this.shouldLevelBeCompleted()) {
                    window.requestAnimationFrame(this.onCompleteCallback);
                }
                
                if (this.onFailedCallback && this.shouldLevelBeFailed()) {
                    window.requestAnimationFrame(this.onFailedCallback);
                }
            };
            
            updatePlayerView(dt) {
                const playerContainer = this.getPlayerContainer();
                if (!playerContainer) return;
                
                if (this.timeLeft) this.timeLeft = Math.max(0, this.timeLeft - dt);
                
                this.playerState.health = playerContainer.get(HealthComponent).current;
                this.playerState.ammo = playerContainer.get(PlayerComponent).weapons[WEAPON_PISTOL_INDEX]?.bulletTotal;
                
                this.levelPlayerView.render({
                    soundMuted: this.soundManager.checkMuted(),
                    ammo: this.playerState.ammo,
                    health: this.playerState.health,
                    timeLeft: this.timeLeft,
                });
            }
            
            onComplete(cb) {
                this.onCompleteCallback = cb;
            }
            
            onFailed(cb) {
                this.onFailedCallback = cb;
            }
            
            toogleMusicControl() {
                if (this.soundManager.checkMuted()) {
                    this.soundManager.unmute();
                } else {
                    this.soundManager.mute();
                }
            }
            
            handleDocumentKeypress = (e) => {
                if (e.code === "KeyM") {
                    this.toogleMusicControl();
                }
            };
            
            createListeners() {
                document.addEventListener("keypress", this.handleDocumentKeypress);
            }
            
            destroyListeners() {
                document.removeEventListener("keypress", this.handleDocumentKeypress);
            }
            
            start() {
                this.startedAt = Date.now();
                this.ecs.start();
                this.loop.play();
                this.levelPlayerView.render({
                    soundMuted: this.soundManager.checkMuted(),
                    ammo: this.playerState.ammo,
                    health: this.playerState.health,
                    timeLeft: this.timeLeft,
                });
                this.createListeners();
            }
            
            destroy() {
                this.loop.pause();
                this.ecs.destroy();
                this.levelPlayerView.destroy();
                this.destroyListeners();
            }
        }
        
        // ===== LEVELS =====
        function generateZombie(x, y, aiDistance = 0) {
            return {
                x, y, aiDistance, type: "zombie", health: 100, radius: 0.4,
                meleeWeapon: { damage: 5, frequency: 1000 },
            };
        }
        
        function generateFlyguy(x, y, aiDistance = 0) {
            return {
                x, y, aiDistance, type: "flyguy", health: 150, radius: 0.4,
                rangeWeapon: { bulletSprite: "pistol_bullet", bulletDamage: 5, bulletSpeed: 8, attackDistance: 2, attackFrequency: 1000 },
            };
        }
        
        function generateSoldier(x, y, aiDistance = 0) {
            return {
                x, y, aiDistance, type: "soldier", health: 200, radius: 0.4,
                rangeWeapon: { bulletSprite: "shotgun_bullet", bulletDamage: 10, bulletSpeed: 6, attackDistance: 2, attackFrequency: 1500 },
            };
        }
        
        function generateCommando(x, y, aiDistance = 0) {
            return {
                x, y, aiDistance, type: "commando", health: 500, radius: 0.6,
                rangeWeapon: { bulletSprite: "shotgun_bullet", bulletDamage: 15, bulletSpeed: 7, attackDistance: 3, attackFrequency: 1500 },
            };
        }
        
        function generateTank(x, y, aiDistance = 0) {
            return {
                x, y, aiDistance, type: "tank", health: 2000, radius: 0.4,
                rangeWeapon: { bulletSprite: "shotgun_bullet", bulletDamage: 25, bulletSpeed: 5, attackDistance: 3, attackFrequency: 750 },
            };
        }
        
        function generateEntities(generator) {
            return (limit, x, y, dx, dy, ai = 0) => {
                return new Array(limit).fill(0).map(() => generator(x + (Math.random() * 2 - 1) * dx, y + (Math.random() * 2 - 1) * dy, ai));
            };
        }
        
        function generateCircle(x, y, radius, total) {
            const step = 360 / total;
            const coords = [];
            for (let angle = 0; angle < 360; angle += step) {
                coords.push([
                    x + radius * Math.cos(degreeToRadians(angle)),
                    y + radius * Math.sin(degreeToRadians(angle)),
                ]);
            }
            return coords;
        }
        
        const generateZombies = generateEntities(generateZombie);
        const generateSoldiers = generateEntities(generateSoldier);
        const generateCommandos = generateEntities(generateCommando);
        const generateFlygies = generateEntities(generateFlyguy);
        const generateTanks = generateEntities(generateTank);
        
        function generatePistol(x, y, value) {
            return { type: "pistol_weapon", radius: 0.3, x, y, value };
        }
        
        function generatePistolAmmo(x, y, value) {
            return { type: "pistol_ammo", radius: 0.3, x, y, value };
        }
        
        function generateHealthPack(x, y, value) {
            return { type: "health_pack", radius: 0.3, x, y, value };
        }
        
        const level_1 = {
            world: {
                colors: {
                    top: { r: 0, g: 0, b: 0, a: 255 },
                    bottom: { r: 84, g: 98, b: 92, a: 255 },
                },
            },
            music: "shocking-red-abbynoise",
            map: [
                ['#', '#', '#', '#', '&', '#', '#', '#', '#', '#', '#', '&', '#', '#', '#', '#', '#', '#', '#', '#'],
                ['#', ' ', ' ', ' ', '&', ' ', '*', ' ', ' ', ' ', ' ', '&', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '#'],
                ['5', ' ', ' ', ' ', '|', ' ', ' ', '&', ' ', ' ', ' ', '&', ' ', ' ', '&', ' ', ' ', ' ', ' ', '4'],
                ['#', ' ', ' ', ' ', '&', ' ', '&', '&', ' ', ' ', ' ', '&', ' ', ' ', '&', ' ', ' ', ' ', ' ', '#'],
                ['#', ' ', ' ', ' ', ' ', ' ', ' ', '&', ' ', ' ', ' ', ' ', ' ', ' ', '&', ' ', ' ', ' ', ' ', '#'],
                ['#', ' ', ' ', ' ', ' ', ' ', ' ', '&', ' ', ' ', ' ', ' ', ' ', ' ', '&', ' ', ' ', ' ', '*', '#'],
                ['#', '#', '#', '#', '#', '#', '#', '&', '#', '#', '#', '#', '#', '#', '&', '#', '#', '#', '#', '#'],
            ],
            mapEntities: {
                " ": { type: "empty" },
                "#": { type: "wall", texture: "TECH_1C" },
                "&": { type: "wall", texture: "TECH_1E" },
                "4": { type: "wall", texture: "DOOR_1A" },
                "5": { type: "wall", texture: "DOOR_1E" },
                "|": { type: "door", texture: "DOOR_1A" },
                "*": { type: "light" },
            },
            player: { x: 1.5, y: 2.5, angle: 0, health: 100 },
            items: [
                generatePistol(3.5, 1.6, 15),
                generatePistolAmmo(3.5, 1.8, 15),
                generatePistolAmmo(3.5, 2, 15),
                generatePistolAmmo(3.5, 2.2, 15),
                generatePistolAmmo(3.5, 2.4, 15),
                generatePistolAmmo(16, 5, 15),
            ],
            enemies: [
                generateSoldier(18, 1.75, 4),
                generateSoldier(18, 3.25, 4),
                ...generateZombies(10, 6, 2.5, 0.75, 0.75, 2),
                ...generateZombies(10, 9.5, 4.5, 1, 0.75, 2),
                ...generateZombies(10, 13, 2.5, 0.75, 0.75, 2),
            ],
            endingScenario: { name: "exit", position: { x: 18, y: 2 } },
        };
        
        const level_2 = {
            world: {
                colors: {
                    top: { r: 0, g: 0, b: 0, a: 255 },
                    bottom: { r: 84, g: 98, b: 92, a: 255 },
                },
            },
            music: "heavy-duty-zoo",
            map: [
                [1, 5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 4],
                [1, 0, 1, 0, 0, 2, 1, 0, 0, 1, 0, 1, 0, 2, 1, 1, 0, 0, 0, 1, 0, 2, 2, 1],
                [1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1],
                [1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 2, 2, 0, 1],
                [1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1],
                [1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 2, 2, 1],
                [1, 0, 1, 0, 0, 1, 0, 0, 0, 2, 0, 2, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1],
                [1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 2, 1, 1, 2, 2, 0, 1],
                [1, 0, 2, 0, 0, 1, 0, 0, 0, 2, 0, 2, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1],
            ],
            mapEntities: {
                0: { type: "empty" },
                1: { type: "wall", texture: "TECH_1C" },
                2: { type: "wall", texture: "TECH_1E" },
                3: { type: "wall", texture: "TECH_2F" },
                4: { type: "wall", texture: "DOOR_1A" },
                5: { type: "wall", texture: "DOOR_1E" },
            },
            player: { x: 1.5, y: 1.5, angle: 90, health: 100 },
            items: [
                generatePistolAmmo(1.5, 9.5, 15),
                generatePistolAmmo(6.5, 3.5, 15),
                generatePistolAmmo(6.5, 5.5, 15),
                generatePistolAmmo(6.5, 7.5, 15),
                generatePistolAmmo(6.5, 9.5, 15),
                generatePistolAmmo(10.5, 1, 20),
                generatePistolAmmo(10.5, 2, 20),
                generatePistolAmmo(10.5, 2.5, 20),
                generatePistolAmmo(10.5, 3, 20),
                generatePistolAmmo(10.5, 3.5, 20),
                generatePistolAmmo(10.5, 4, 20),
                generatePistolAmmo(10.5, 4.5, 20),
                generatePistolAmmo(10.5, 5, 20),
                generatePistolAmmo(10.5, 5.5, 20),
                generateHealthPack(10.5, 6, 100),
            ],
            enemies: [
                generateZombie(1.5, 9.5, 2),
                generateSoldier(6, 1, 3),
                generateSoldier(4.5, 6.5, 4),
                generateSoldier(4.5, 7.5, 4),
                generateSoldier(4.5, 8.5, 4),
                generateSoldier(4.5, 9.5, 4),
                generateSoldier(4.5, 10.5, 4),
                ...generateZombies(15, 4.5, 4.5, 1, 1, 1),
                generateZombie(7, 3.5, 2),
                generateZombie(7, 5.5, 2),
                generateZombie(7, 7.5, 2),
                generateZombie(7, 9.5, 2),
                generateZombie(7, 9.5, 2),
                generateZombie(10.5, 7.5, 2),
                generateZombie(10.5, 9.5, 2),
                generateZombie(12.5, 7.5, 2),
                generateZombie(12.5, 9.5, 2),
                generateZombie(14.5, 7.5, 2),
                generateZombie(14.5, 8.5, 2),
                generateZombie(14.5, 9.5, 2),
                generateZombie(18.5, 1.5, 2),
                generateZombie(18.5, 2.5, 2),
                generateZombie(18.5, 3.5, 2),
                generateZombie(18.5, 4.5, 2),
                ...generateZombies(15, 14.5, 4.5, 1, 1, 2),
                ...generateZombies(25, 18, 5, 1, 1, 2),
                ...generateZombies(25, 17, 7, 1, 1, 2),
                ...generateZombies(15, 16, 8, 1, 1, 2),
                ...generateZombies(50, 17, 2, 1, 1, 2),
            ],
            endingScenario: { name: "exit", position: { x: 22, y: 1 } },
        };
        
        const level_3 = {
            world: {
                colors: {
                    top: { r: 0, g: 0, b: 0, a: 255 },
                    bottom: { r: 84, g: 98, b: 92, a: 255 },
                },
            },
            music: "heavy-duty-zoo",
            map: [
                [1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 2, 0, 0, 0, 0, 4],
                [1, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 2, 0, 0, 0, 0, 1],
                [1, 0, 0, 2, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 1],
                [1, 0, 0, 2, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 1],
                [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 1],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1],
            ],
            mapEntities: {
                0: { type: "empty" },
                1: { type: "wall", texture: "TECH_1C" },
                2: { type: "wall", texture: "TECH_1E" },
                3: { type: "wall", texture: "TECH_2F" },
                4: { type: "wall", texture: "DOOR_1A" },
                5: { type: "wall", texture: "DOOR_1E" },
            },
            player: { x: 2, y: 2.5, angle: 90, health: 100 },
            items: [
                generatePistolAmmo(1.75, 7.5, 15),
                generatePistolAmmo(2, 7.5, 15),
                generatePistolAmmo(2.25, 7.5, 15),
            ],
            enemies: [
                ...generateFlygies(10, 7, 2, 1, 1, 3),
                ...generateZombies(20, 8, 3, 1, 1, 5),
                ...generateSoldiers(20, 8, 8, 1, 1, 5),
            ],
            endingScenario: { name: "exit", position: { x: 18, y: 2 } },
        };
        
        const level_final = {
            world: {
                colors: {
                    top: { r: 0, g: 0, b: 0, a: 255 },
                    bottom: { r: 84, g: 98, b: 92, a: 255 },
                },
            },
            music: "zombie-world-alex-besss",
            map: [
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1],
                [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1],
                [1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            ],
            mapEntities: {
                0: { type: "empty" },
                1: { type: "wall", texture: "TECH_1C" },
                2: { type: "wall", texture: "TECH_1E" },
                3: { type: "wall", texture: "TECH_2F" },
                4: { type: "wall", texture: "DOOR_1A" },
                5: { type: "wall", texture: "DOOR_1E" },
            },
            player: { x: 5.5, y: 5.5, angle: 90, health: 100 },
            items: [
                generatePistolAmmo(3.5, 3.5, 15),
                generatePistolAmmo(3.5, 9.5, 15),
                generatePistolAmmo(9.5, 3.5, 15),
                generatePistolAmmo(9.5, 9.5, 15),
                ...generateCircle(6.5, 6.5, 3.5, 4).map(([x, y]) => generatePistolAmmo(x, y, 15)),
            ],
            enemies: [
                ...generateZombies(3, 4, 4, 0.5, 0.5, 8),
                ...generateZombies(3, 4, 8, 0.5, 0.5, 8),
                ...generateZombies(3, 8, 4, 0.5, 0.5, 8),
                ...generateZombies(3, 8, 8, 0.5, 0.5, 8),
                ...generateCircle(6.5, 6.5, 3.5, 10).map(([x, y]) => generateZombie(x, y, 10)),
                generateTank(2, 2, 6),
                generateTank(2, 8, 6),
                generateTank(8, 2, 6),
                generateTank(8, 8, 6),
            ],
            endingScenario: { name: "survive", timer: 30 },
        };
        
        const levels = [level_1, level_2, level_3, level_final];
        
        // ===== ASSETS =====
        const textures = [
            { id: "TECH_1C", url: "https://ufocoder.github.io/fps/assets/textures/TECH_1C.PNG" },
            { id: "TECH_1E", url: "https://ufocoder.github.io/fps/assets/textures/TECH_1E.PNG" },
            { id: "TECH_2F", url: "https://ufocoder.github.io/fps/assets/textures/TECH_2F.PNG" },
            { id: "TECH_3B", url: "https://ufocoder.github.io/fps/assets/textures/TECH_3B.PNG" },
            { id: "TECH_4E", url: "https://ufocoder.github.io/fps/assets/textures/TECH_4E.PNG" },
            { id: "TECH_4F", url: "https://ufocoder.github.io/fps/assets/textures/TECH_4F.PNG" },
            { id: "DOOR_1A", url: "https://ufocoder.github.io/fps/assets/textures/DOOR_1A.PNG" },
            { id: "DOOR_1C", url: "https://ufocoder.github.io/fps/assets/textures/DOOR_1C.PNG" },
            { id: "DOOR_1E", url: "https://ufocoder.github.io/fps/assets/textures/DOOR_1E.PNG" },
            { id: "floor", url: "https://ufocoder.github.io/fps/assets/textures/FLOOR_1A.PNG" },
        ];
        
        const sprites = [
            { id: 'health_pack', url: 'https://ufocoder.github.io/fps/assets/items/health_pack.png' },
            { id: 'pistol_weapon', url: 'https://ufocoder.github.io/fps/assets/items/pistol_weapon.png' },
            { id: 'pistol_ammo', url: 'https://ufocoder.github.io/fps/assets/items/pistol_ammo.png' },
            { id: 'pistol_bullet', url: 'https://ufocoder.github.io/fps/assets/weapons/pistol_bullet.png' },
            { id: 'shotgun_bullet', url: 'https://ufocoder.github.io/fps/assets/weapons/shotgun_bullet.gif' },
        ];
        
        const animation = [
            { id: "knifeIdle", frames: ["https://ufocoder.github.io/fps/assets/weapons/knife_1.png"] },
            { id: "knifeAttack", frames: [
                "https://ufocoder.github.io/fps/assets/weapons/knife_1.png",
                "https://ufocoder.github.io/fps/assets/weapons/knife_2.png",
                "https://ufocoder.github.io/fps/assets/weapons/knife_3.png",
                "https://ufocoder.github.io/fps/assets/weapons/knife_4.png",
                "https://ufocoder.github.io/fps/assets/weapons/knife_5.png",
            ]},
            { id: "pistolIdle", frames: ["https://ufocoder.github.io/fps/assets/weapons/pistol_1.png"] },
            { id: "pistolAttack", frames: [
                "https://ufocoder.github.io/fps/assets/weapons/pistol_1.png",
                "https://ufocoder.github.io/fps/assets/weapons/pistol_2.png",
                "https://ufocoder.github.io/fps/assets/weapons/pistol_3.png",
                "https://ufocoder.github.io/fps/assets/weapons/pistol_4.png",
                "https://ufocoder.github.io/fps/assets/weapons/pistol_5.png",
            ]},
            { id: "zombieIdle", frames: ["https://ufocoder.github.io/fps/assets/characters/ZombieIdle.png"] },
            { id: "zombieWalk", frames: [
                "https://ufocoder.github.io/fps/assets/characters/ZombieWalk1.png",
                "https://ufocoder.github.io/fps/assets/characters/ZombieWalk2.png",
                "https://ufocoder.github.io/fps/assets/characters/ZombieWalk3.png",
                "https://ufocoder.github.io/fps/assets/characters/ZombieWalk4.png",
            ]},
            { id: "zombieDamage", frames: [
                "https://ufocoder.github.io/fps/assets/characters/ZombieDamage1.png",
                "https://ufocoder.github.io/fps/assets/characters/ZombieDamage2.png",
            ]},
            { id: "zombieDeath", frames: [
                "https://ufocoder.github.io/fps/assets/characters/ZombieDeath1.png",
                "https://ufocoder.github.io/fps/assets/characters/ZombieDeath2.png",
                "https://ufocoder.github.io/fps/assets/characters/ZombieDeath3.png",
                "https://ufocoder.github.io/fps/assets/characters/ZombieDeath4.png",
            ]},
            { id: "zombieAttack", frames: [
                "https://ufocoder.github.io/fps/assets/characters/ZombieAttack1.png",
                "https://ufocoder.github.io/fps/assets/characters/ZombieAttack2.png",
            ]},
            { id: "flyguyIdle", frames: ["https://ufocoder.github.io/fps/assets/characters/FlyguyIdle.png"] },
            { id: "flyguyWalk", frames: [
                "https://ufocoder.github.io/fps/assets/characters/FlyguyWalk1.png",
                "https://ufocoder.github.io/fps/assets/characters/FlyguyWalk2.png",
                "https://ufocoder.github.io/fps/assets/characters/FlyguyWalk3.png",
                "https://ufocoder.github.io/fps/assets/characters/FlyguyWalk4.png",
            ]},
            { id: "flyguyDamage", frames: [
                "https://ufocoder.github.io/fps/assets/characters/FlyguyDamage1.png",
                "https://ufocoder.github.io/fps/assets/characters/FlyguyDamage2.png",
            ]},
            { id: "flyguyDeath", frames: [
                "https://ufocoder.github.io/fps/assets/characters/FlyguyDeath1.png",
                "https://ufocoder.github.io/fps/assets/characters/FlyguyDeath2.png",
                "https://ufocoder.github.io/fps/assets/characters/FlyguyDeath3.png",
                "https://ufocoder.github.io/fps/assets/characters/FlyguyDeath4.png",
            ]},
            { id: "flyguyAttack", frames: [
                "https://ufocoder.github.io/fps/assets/characters/FlyguyAttack1.png",
                "https://ufocoder.github.io/fps/assets/characters/FlyguyAttack2.png",
            ]},
            { id: "soldierIdle", frames: ["https://ufocoder.github.io/fps/assets/characters/SoldierIdle.png"] },
            { id: "soldierWalk", frames: [
                "https://ufocoder.github.io/fps/assets/characters/SoldierWalk1.png",
                "https://ufocoder.github.io/fps/assets/characters/SoldierWalk2.png",
                "https://ufocoder.github.io/fps/assets/characters/SoldierWalk3.png",
                "https://ufocoder.github.io/fps/assets/characters/SoldierWalk4.png",
            ]},
            { id: "soldierDamage", frames: [
                "https://ufocoder.github.io/fps/assets/characters/SoldierDamage1.png",
                "https://ufocoder.github.io/fps/assets/characters/SoldierDamage2.png",
            ]},
            { id: "soldierDeath", frames: [
                "https://ufocoder.github.io/fps/assets/characters/SoldierDeath1.png",
                "https://ufocoder.github.io/fps/assets/characters/SoldierDeath2.png",
                "https://ufocoder.github.io/fps/assets/characters/SoldierDeath3.png",
                "https://ufocoder.github.io/fps/assets/characters/SoldierDeath4.png",
            ]},
            { id: "soldierAttack", frames: [
                "https://ufocoder.github.io/fps/assets/characters/SoldierAttack1.png",
                "https://ufocoder.github.io/fps/assets/characters/SoldierAttack2.png",
            ]},
            { id: "commandoIdle", frames: ["https://ufocoder.github.io/fps/assets/characters/CommandoIdle.png"] },
            { id: "commandoWalk", frames: [
                "https://ufocoder.github.io/fps/assets/characters/CommandoWalk1.png",
                "https://ufocoder.github.io/fps/assets/characters/CommandoWalk2.png",
                "https://ufocoder.github.io/fps/assets/characters/CommandoWalk3.png",
                "https://ufocoder.github.io/fps/assets/characters/CommandoWalk4.png",
            ]},
            { id: "commandoDamage", frames: [
                "https://ufocoder.github.io/fps/assets/characters/CommandoDamage1.png",
                "https://ufocoder.github.io/fps/assets/characters/CommandoDamage2.png",
            ]},
            { id: "commandoDeath", frames: [
                "https://ufocoder.github.io/fps/assets/characters/CommandoDeath1.png",
                "https://ufocoder.github.io/fps/assets/characters/CommandoDeath2.png",
                "https://ufocoder.github.io/fps/assets/characters/CommandoDeath3.png",
                "https://ufocoder.github.io/fps/assets/characters/CommandoDeath4.png",
            ]},
            { id: "commandoAttack", frames: [
                "https://ufocoder.github.io/fps/assets/characters/CommandoAttack1.png",
                "https://ufocoder.github.io/fps/assets/characters/CommandoAttack2.png",
            ]},
            { id: "tankIdle", frames: ["https://ufocoder.github.io/fps/assets/characters/TankIdle.png"] },
            { id: "tankWalk", frames: [
                "https://ufocoder.github.io/fps/assets/characters/TankWalk1.png",
                "https://ufocoder.github.io/fps/assets/characters/TankWalk2.png",
                "https://ufocoder.github.io/fps/assets/characters/TankWalk3.png",
                "https://ufocoder.github.io/fps/assets/characters/TankWalk4.png",
            ]},
            { id: "tankDamage", frames: [
                "https://ufocoder.github.io/fps/assets/characters/TankDamage1.png",
                "https://ufocoder.github.io/fps/assets/characters/TankDamage2.png",
            ]},
            { id: "tankDeath", frames: [
                "https://ufocoder.github.io/fps/assets/characters/TankDeath1.png",
                "https://ufocoder.github.io/fps/assets/characters/TankDeath2.png",
                "https://ufocoder.github.io/fps/assets/characters/TankDeath3.png",
                "https://ufocoder.github.io/fps/assets/characters/TankDeath4.png",
            ]},
            { id: "tankAttack", frames: [
                "https://ufocoder.github.io/fps/assets/characters/TankAttack1.png",
                "https://ufocoder.github.io/fps/assets/characters/TankAttack2.png",
            ]},
        ];
        
        const sounds = [
            { id: 'hurt', url: 'https://ufocoder.github.io/fps/assets/sounds/hurt.mp3', volume: 1 },
            { id: 'pick', url: 'https://ufocoder.github.io/fps/assets/sounds/pick.mp3', volume: 1 },
            { id: 'gun-shot', url: 'https://ufocoder.github.io/fps/assets/sounds/gun-shot.mp3', volume: 1 },
            { id: 'lazer-shot', url: 'https://ufocoder.github.io/fps/assets/sounds/lazer-shot.mp3', volume: 1 },
            { id: 'attack-zombie', url: 'https://ufocoder.github.io/fps/assets/sounds/attack-zombie.mp3', volume: 1 },
            { id: 'attack-knife', url: 'https://ufocoder.github.io/fps/assets/sounds/attack-knife.mp3', volume: 1 },
            { id: 'heavy-duty-zoo', url: 'https://ufocoder.github.io/fps/assets/music/heavy-duty-zoo.mp3', volume: 0.8 },
            { id: 'shocking-red-abbynoise', url: 'https://ufocoder.github.io/fps/assets/music/shocking-red-abbynoise.mp3', volume: 0.8 },
            { id: 'zombie-world-alex-besss', url: 'https://ufocoder.github.io/fps/assets/music/zombie-world-alex-besss.mp3', volume: 0.8 },
        ];
        
        // ===== SCENARIO =====
        function createScenario({ container, soundManager, textureManager, animationManager }) {
            let levelIndex = 0;
            const playerState = { health: 100 };
            
            const showFinalScene = () => {
                const scene = new TitleScene(container, playerState, "Congratulation!", ["You survived a zombie invasion"]);
                scene.start();
            };
            
            const showFailedScene = () => {
                const scene = new TitleScene(container, playerState, "You died");
                scene.start();
            };
            
            const switchToLevelNextScene = (playerState) => {
                const level = levels[levelIndex];
                if (!level) {
                    showFinalScene();
                    return;
                }
                
                levelIndex++;
                
                const scene = new LevelScene({
                    level,
                    container,
                    soundManager,
                    textureManager,
                    animationManager,
                    playerState,
                });
                
                scene.onComplete(() => {
                    if (level.music) soundManager.pauseBackground();
                    scene.destroy();
                    switchToLevelNextScene(scene.playerState);
                });
                
                scene.onFailed(() => {
                    if (level.music) soundManager.pauseBackground();
                    scene.destroy();
                    showFailedScene();
                });
                
                scene.start();
                if (level.music) soundManager.playBackground(level.music);
            };
            
            const startScene = new TitleScene(container, playerState, "Shoot or run", [
                "Use WASD and mouse to play",
                "Use M to mute",
                "",
                "Press any key to start"
            ]);
            
            startScene.onComplete(() => {
                startScene.destroy();
                switchToLevelNextScene(playerState);
            });
            
            startScene.start();
        }
        
        // ===== MAIN =====
        const container = document.getElementById('app');
        const soundManager = new SoundManager();
        const textureManager = new TextureManager();
        const animationManager = new AnimationManager();
        
        window.onload = async () => {
            try {
                await Promise.all([
                    soundManager.load(sounds),
                    textureManager.load([...textures, ...sprites]),
                    animationManager.load(animation),
                ]);
                
                container.innerHTML = '';
                createScenario({ container, soundManager, textureManager, animationManager });
            } catch (err) {
                console.warn(err);
                container.innerHTML = 'Error loading game assets. Please check your internet connection.';
            }
        };
    </script>
</body>
</html>
